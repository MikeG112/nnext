// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: main.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_main_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_main_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_main_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_main_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[31]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_main_2eproto;
namespace nnext {
class CreateIndexRequest;
struct CreateIndexRequestDefaultTypeInternal;
extern CreateIndexRequestDefaultTypeInternal _CreateIndexRequest_default_instance_;
class CreateIndexResponse;
struct CreateIndexResponseDefaultTypeInternal;
extern CreateIndexResponseDefaultTypeInternal _CreateIndexResponse_default_instance_;
class DataList;
struct DataListDefaultTypeInternal;
extern DataListDefaultTypeInternal _DataList_default_instance_;
class Datum;
struct DatumDefaultTypeInternal;
extern DatumDefaultTypeInternal _Datum_default_instance_;
class DropIndexRequest;
struct DropIndexRequestDefaultTypeInternal;
extern DropIndexRequestDefaultTypeInternal _DropIndexRequest_default_instance_;
class DropIndexResponse;
struct DropIndexResponseDefaultTypeInternal;
extern DropIndexResponseDefaultTypeInternal _DropIndexResponse_default_instance_;
class IdMap;
struct IdMapDefaultTypeInternal;
extern IdMapDefaultTypeInternal _IdMap_default_instance_;
class IdMap_IdxEntry_DoNotUse;
struct IdMap_IdxEntry_DoNotUseDefaultTypeInternal;
extern IdMap_IdxEntry_DoNotUseDefaultTypeInternal _IdMap_IdxEntry_DoNotUse_default_instance_;
class IdMap_InvEntry_DoNotUse;
struct IdMap_InvEntry_DoNotUseDefaultTypeInternal;
extern IdMap_InvEntry_DoNotUseDefaultTypeInternal _IdMap_InvEntry_DoNotUse_default_instance_;
class Index;
struct IndexDefaultTypeInternal;
extern IndexDefaultTypeInternal _Index_default_instance_;
class IndexList;
struct IndexListDefaultTypeInternal;
extern IndexListDefaultTypeInternal _IndexList_default_instance_;
class IndexMap;
struct IndexMapDefaultTypeInternal;
extern IndexMapDefaultTypeInternal _IndexMap_default_instance_;
class IndexMap_IndicesEntry_DoNotUse;
struct IndexMap_IndicesEntry_DoNotUseDefaultTypeInternal;
extern IndexMap_IndicesEntry_DoNotUseDefaultTypeInternal _IndexMap_IndicesEntry_DoNotUse_default_instance_;
class ListIndicesRequest;
struct ListIndicesRequestDefaultTypeInternal;
extern ListIndicesRequestDefaultTypeInternal _ListIndicesRequest_default_instance_;
class ListIndicesResponse;
struct ListIndicesResponseDefaultTypeInternal;
extern ListIndicesResponseDefaultTypeInternal _ListIndicesResponse_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Schema;
struct SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class SchemaItem;
struct SchemaItemDefaultTypeInternal;
extern SchemaItemDefaultTypeInternal _SchemaItem_default_instance_;
class Schema_SchemaMapEntry_DoNotUse;
struct Schema_SchemaMapEntry_DoNotUseDefaultTypeInternal;
extern Schema_SchemaMapEntry_DoNotUseDefaultTypeInternal _Schema_SchemaMapEntry_DoNotUse_default_instance_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
class VectorAddRequest;
struct VectorAddRequestDefaultTypeInternal;
extern VectorAddRequestDefaultTypeInternal _VectorAddRequest_default_instance_;
class VectorAddResponse;
struct VectorAddResponseDefaultTypeInternal;
extern VectorAddResponseDefaultTypeInternal _VectorAddResponse_default_instance_;
class VectorClearRequest;
struct VectorClearRequestDefaultTypeInternal;
extern VectorClearRequestDefaultTypeInternal _VectorClearRequest_default_instance_;
class VectorClearResponse;
struct VectorClearResponseDefaultTypeInternal;
extern VectorClearResponseDefaultTypeInternal _VectorClearResponse_default_instance_;
class VectorDeleteRequest;
struct VectorDeleteRequestDefaultTypeInternal;
extern VectorDeleteRequestDefaultTypeInternal _VectorDeleteRequest_default_instance_;
class VectorDeleteResponse;
struct VectorDeleteResponseDefaultTypeInternal;
extern VectorDeleteResponseDefaultTypeInternal _VectorDeleteResponse_default_instance_;
class VectorGetRequest;
struct VectorGetRequestDefaultTypeInternal;
extern VectorGetRequestDefaultTypeInternal _VectorGetRequest_default_instance_;
class VectorGetResponse;
struct VectorGetResponseDefaultTypeInternal;
extern VectorGetResponseDefaultTypeInternal _VectorGetResponse_default_instance_;
class VectorList;
struct VectorListDefaultTypeInternal;
extern VectorListDefaultTypeInternal _VectorList_default_instance_;
class VectorSearchRequest;
struct VectorSearchRequestDefaultTypeInternal;
extern VectorSearchRequestDefaultTypeInternal _VectorSearchRequest_default_instance_;
class VectorSearchResponse;
struct VectorSearchResponseDefaultTypeInternal;
extern VectorSearchResponseDefaultTypeInternal _VectorSearchResponse_default_instance_;
}  // namespace nnext
PROTOBUF_NAMESPACE_OPEN
template<> ::nnext::CreateIndexRequest* Arena::CreateMaybeMessage<::nnext::CreateIndexRequest>(Arena*);
template<> ::nnext::CreateIndexResponse* Arena::CreateMaybeMessage<::nnext::CreateIndexResponse>(Arena*);
template<> ::nnext::DataList* Arena::CreateMaybeMessage<::nnext::DataList>(Arena*);
template<> ::nnext::Datum* Arena::CreateMaybeMessage<::nnext::Datum>(Arena*);
template<> ::nnext::DropIndexRequest* Arena::CreateMaybeMessage<::nnext::DropIndexRequest>(Arena*);
template<> ::nnext::DropIndexResponse* Arena::CreateMaybeMessage<::nnext::DropIndexResponse>(Arena*);
template<> ::nnext::IdMap* Arena::CreateMaybeMessage<::nnext::IdMap>(Arena*);
template<> ::nnext::IdMap_IdxEntry_DoNotUse* Arena::CreateMaybeMessage<::nnext::IdMap_IdxEntry_DoNotUse>(Arena*);
template<> ::nnext::IdMap_InvEntry_DoNotUse* Arena::CreateMaybeMessage<::nnext::IdMap_InvEntry_DoNotUse>(Arena*);
template<> ::nnext::Index* Arena::CreateMaybeMessage<::nnext::Index>(Arena*);
template<> ::nnext::IndexList* Arena::CreateMaybeMessage<::nnext::IndexList>(Arena*);
template<> ::nnext::IndexMap* Arena::CreateMaybeMessage<::nnext::IndexMap>(Arena*);
template<> ::nnext::IndexMap_IndicesEntry_DoNotUse* Arena::CreateMaybeMessage<::nnext::IndexMap_IndicesEntry_DoNotUse>(Arena*);
template<> ::nnext::ListIndicesRequest* Arena::CreateMaybeMessage<::nnext::ListIndicesRequest>(Arena*);
template<> ::nnext::ListIndicesResponse* Arena::CreateMaybeMessage<::nnext::ListIndicesResponse>(Arena*);
template<> ::nnext::Metadata* Arena::CreateMaybeMessage<::nnext::Metadata>(Arena*);
template<> ::nnext::Schema* Arena::CreateMaybeMessage<::nnext::Schema>(Arena*);
template<> ::nnext::SchemaItem* Arena::CreateMaybeMessage<::nnext::SchemaItem>(Arena*);
template<> ::nnext::Schema_SchemaMapEntry_DoNotUse* Arena::CreateMaybeMessage<::nnext::Schema_SchemaMapEntry_DoNotUse>(Arena*);
template<> ::nnext::Vector* Arena::CreateMaybeMessage<::nnext::Vector>(Arena*);
template<> ::nnext::VectorAddRequest* Arena::CreateMaybeMessage<::nnext::VectorAddRequest>(Arena*);
template<> ::nnext::VectorAddResponse* Arena::CreateMaybeMessage<::nnext::VectorAddResponse>(Arena*);
template<> ::nnext::VectorClearRequest* Arena::CreateMaybeMessage<::nnext::VectorClearRequest>(Arena*);
template<> ::nnext::VectorClearResponse* Arena::CreateMaybeMessage<::nnext::VectorClearResponse>(Arena*);
template<> ::nnext::VectorDeleteRequest* Arena::CreateMaybeMessage<::nnext::VectorDeleteRequest>(Arena*);
template<> ::nnext::VectorDeleteResponse* Arena::CreateMaybeMessage<::nnext::VectorDeleteResponse>(Arena*);
template<> ::nnext::VectorGetRequest* Arena::CreateMaybeMessage<::nnext::VectorGetRequest>(Arena*);
template<> ::nnext::VectorGetResponse* Arena::CreateMaybeMessage<::nnext::VectorGetResponse>(Arena*);
template<> ::nnext::VectorList* Arena::CreateMaybeMessage<::nnext::VectorList>(Arena*);
template<> ::nnext::VectorSearchRequest* Arena::CreateMaybeMessage<::nnext::VectorSearchRequest>(Arena*);
template<> ::nnext::VectorSearchResponse* Arena::CreateMaybeMessage<::nnext::VectorSearchResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace nnext {

enum IndexType : int {
  APPROXIMATED = 0,
  EXACT = 1,
  IndexType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IndexType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IndexType_IsValid(int value);
constexpr IndexType IndexType_MIN = APPROXIMATED;
constexpr IndexType IndexType_MAX = EXACT;
constexpr int IndexType_ARRAYSIZE = IndexType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IndexType_descriptor();
template<typename T>
inline const std::string& IndexType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IndexType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IndexType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IndexType_descriptor(), enum_t_value);
}
inline bool IndexType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IndexType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IndexType>(
    IndexType_descriptor(), name, value);
}
enum MetricType : int {
  EUCLIDEAN = 0,
  MANHATTAN = 1,
  CHEBYSHEV = 2,
  MetricType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MetricType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MetricType_IsValid(int value);
constexpr MetricType MetricType_MIN = EUCLIDEAN;
constexpr MetricType MetricType_MAX = CHEBYSHEV;
constexpr int MetricType_ARRAYSIZE = MetricType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetricType_descriptor();
template<typename T>
inline const std::string& MetricType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MetricType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MetricType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MetricType_descriptor(), enum_t_value);
}
inline bool MetricType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MetricType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MetricType>(
    MetricType_descriptor(), name, value);
}
enum DataType : int {
  unknown = 0,
  double_ = 1,
  float_ = 2,
  int32 = 3,
  string = 4,
  DataType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DataType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DataType_IsValid(int value);
constexpr DataType DataType_MIN = unknown;
constexpr DataType DataType_MAX = string;
constexpr int DataType_ARRAYSIZE = DataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DataType_descriptor();
template<typename T>
inline const std::string& DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DataType_descriptor(), enum_t_value);
}
inline bool DataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DataType>(
    DataType_descriptor(), name, value);
}
// ===================================================================

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  explicit constexpr Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  enum MetafieldCase {
    kDouble = 1,
    kFloat = 2,
    kInt32 = 3,
    kInt64 = 4,
    kUint32 = 5,
    kUint64 = 6,
    kSint32 = 7,
    kSint64 = 8,
    kFixed32 = 9,
    kFixed64 = 10,
    kSfixed32 = 11,
    kSfixed64 = 12,
    kBool = 13,
    kString = 14,
    kBytes = 15,
    METAFIELD_NOT_SET = 0,
  };

  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  inline void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Metadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Metadata& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 16,
    kTypeFieldNumber = 17,
    kDoubleFieldNumber = 1,
    kFloatFieldNumber = 2,
    kInt32FieldNumber = 3,
    kInt64FieldNumber = 4,
    kUint32FieldNumber = 5,
    kUint64FieldNumber = 6,
    kSint32FieldNumber = 7,
    kSint64FieldNumber = 8,
    kFixed32FieldNumber = 9,
    kFixed64FieldNumber = 10,
    kSfixed32FieldNumber = 11,
    kSfixed64FieldNumber = 12,
    kBoolFieldNumber = 13,
    kStringFieldNumber = 14,
    kBytesFieldNumber = 15,
  };
  // string name = 16;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .nnext.DataType type = 17;
  void clear_type();
  ::nnext::DataType type() const;
  void set_type(::nnext::DataType value);
  private:
  ::nnext::DataType _internal_type() const;
  void _internal_set_type(::nnext::DataType value);
  public:

  // double _double = 1;
  bool has__double() const;
  private:
  bool _internal_has__double() const;
  public:
  void clear__double();
  double _double() const;
  void set__double(double value);
  private:
  double _internal__double() const;
  void _internal_set__double(double value);
  public:

  // float _float = 2;
  bool has__float() const;
  private:
  bool _internal_has__float() const;
  public:
  void clear__float();
  float _float() const;
  void set__float(float value);
  private:
  float _internal__float() const;
  void _internal_set__float(float value);
  public:

  // int32 _int32 = 3;
  bool has__int32() const;
  private:
  bool _internal_has__int32() const;
  public:
  void clear__int32();
  int32_t _int32() const;
  void set__int32(int32_t value);
  private:
  int32_t _internal__int32() const;
  void _internal_set__int32(int32_t value);
  public:

  // int64 _int64 = 4;
  bool has__int64() const;
  private:
  bool _internal_has__int64() const;
  public:
  void clear__int64();
  int64_t _int64() const;
  void set__int64(int64_t value);
  private:
  int64_t _internal__int64() const;
  void _internal_set__int64(int64_t value);
  public:

  // uint32 _uint32 = 5;
  bool has__uint32() const;
  private:
  bool _internal_has__uint32() const;
  public:
  void clear__uint32();
  uint32_t _uint32() const;
  void set__uint32(uint32_t value);
  private:
  uint32_t _internal__uint32() const;
  void _internal_set__uint32(uint32_t value);
  public:

  // uint64 _uint64 = 6;
  bool has__uint64() const;
  private:
  bool _internal_has__uint64() const;
  public:
  void clear__uint64();
  uint64_t _uint64() const;
  void set__uint64(uint64_t value);
  private:
  uint64_t _internal__uint64() const;
  void _internal_set__uint64(uint64_t value);
  public:

  // sint32 _sint32 = 7;
  bool has__sint32() const;
  private:
  bool _internal_has__sint32() const;
  public:
  void clear__sint32();
  int32_t _sint32() const;
  void set__sint32(int32_t value);
  private:
  int32_t _internal__sint32() const;
  void _internal_set__sint32(int32_t value);
  public:

  // sint64 _sint64 = 8;
  bool has__sint64() const;
  private:
  bool _internal_has__sint64() const;
  public:
  void clear__sint64();
  int64_t _sint64() const;
  void set__sint64(int64_t value);
  private:
  int64_t _internal__sint64() const;
  void _internal_set__sint64(int64_t value);
  public:

  // fixed32 _fixed32 = 9;
  bool has__fixed32() const;
  private:
  bool _internal_has__fixed32() const;
  public:
  void clear__fixed32();
  uint32_t _fixed32() const;
  void set__fixed32(uint32_t value);
  private:
  uint32_t _internal__fixed32() const;
  void _internal_set__fixed32(uint32_t value);
  public:

  // fixed64 _fixed64 = 10;
  bool has__fixed64() const;
  private:
  bool _internal_has__fixed64() const;
  public:
  void clear__fixed64();
  uint64_t _fixed64() const;
  void set__fixed64(uint64_t value);
  private:
  uint64_t _internal__fixed64() const;
  void _internal_set__fixed64(uint64_t value);
  public:

  // sfixed32 _sfixed32 = 11;
  bool has__sfixed32() const;
  private:
  bool _internal_has__sfixed32() const;
  public:
  void clear__sfixed32();
  int32_t _sfixed32() const;
  void set__sfixed32(int32_t value);
  private:
  int32_t _internal__sfixed32() const;
  void _internal_set__sfixed32(int32_t value);
  public:

  // sfixed64 _sfixed64 = 12;
  bool has__sfixed64() const;
  private:
  bool _internal_has__sfixed64() const;
  public:
  void clear__sfixed64();
  int64_t _sfixed64() const;
  void set__sfixed64(int64_t value);
  private:
  int64_t _internal__sfixed64() const;
  void _internal_set__sfixed64(int64_t value);
  public:

  // bool _bool = 13;
  bool has__bool() const;
  private:
  bool _internal_has__bool() const;
  public:
  void clear__bool();
  bool _bool() const;
  void set__bool(bool value);
  private:
  bool _internal__bool() const;
  void _internal_set__bool(bool value);
  public:

  // string _string = 14;
  bool has__string() const;
  private:
  bool _internal_has__string() const;
  public:
  void clear__string();
  const std::string& _string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__string(ArgT0&& arg0, ArgT... args);
  std::string* mutable__string();
  PROTOBUF_NODISCARD std::string* release__string();
  void set_allocated__string(std::string* _string);
  private:
  const std::string& _internal__string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__string(const std::string& value);
  std::string* _internal_mutable__string();
  public:

  // bytes _bytes = 15;
  bool has__bytes() const;
  private:
  bool _internal_has__bytes() const;
  public:
  void clear__bytes();
  const std::string& _bytes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set__bytes(ArgT0&& arg0, ArgT... args);
  std::string* mutable__bytes();
  PROTOBUF_NODISCARD std::string* release__bytes();
  void set_allocated__bytes(std::string* _bytes);
  private:
  const std::string& _internal__bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set__bytes(const std::string& value);
  std::string* _internal_mutable__bytes();
  public:

  void clear_metafield();
  MetafieldCase metafield_case() const;
  // @@protoc_insertion_point(class_scope:nnext.Metadata)
 private:
  class _Internal;
  void set_has__double();
  void set_has__float();
  void set_has__int32();
  void set_has__int64();
  void set_has__uint32();
  void set_has__uint64();
  void set_has__sint32();
  void set_has__sint64();
  void set_has__fixed32();
  void set_has__fixed64();
  void set_has__sfixed32();
  void set_has__sfixed64();
  void set_has__bool();
  void set_has__string();
  void set_has__bytes();

  inline bool has_metafield() const;
  inline void clear_has_metafield();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  union MetafieldUnion {
    constexpr MetafieldUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    double _double_;
    float _float_;
    int32_t _int32_;
    int64_t _int64_;
    uint32_t _uint32_;
    uint64_t _uint64_;
    int32_t _sint32_;
    int64_t _sint64_;
    uint32_t _fixed32_;
    uint64_t _fixed64_;
    int32_t _sfixed32_;
    int64_t _sfixed64_;
    bool _bool_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _string_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr _bytes_;
  } metafield_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class SchemaItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.SchemaItem) */ {
 public:
  inline SchemaItem() : SchemaItem(nullptr) {}
  ~SchemaItem() override;
  explicit constexpr SchemaItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SchemaItem(const SchemaItem& from);
  SchemaItem(SchemaItem&& from) noexcept
    : SchemaItem() {
    *this = ::std::move(from);
  }

  inline SchemaItem& operator=(const SchemaItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline SchemaItem& operator=(SchemaItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SchemaItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const SchemaItem* internal_default_instance() {
    return reinterpret_cast<const SchemaItem*>(
               &_SchemaItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SchemaItem& a, SchemaItem& b) {
    a.Swap(&b);
  }
  inline void Swap(SchemaItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SchemaItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SchemaItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SchemaItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SchemaItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SchemaItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SchemaItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.SchemaItem";
  }
  protected:
  explicit SchemaItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kTypeFieldNumber = 1,
    kIsPrimaryFieldNumber = 2,
    kIsIndexedFieldNumber = 3,
  };
  // string name = 4;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .nnext.DataType type = 1;
  void clear_type();
  ::nnext::DataType type() const;
  void set_type(::nnext::DataType value);
  private:
  ::nnext::DataType _internal_type() const;
  void _internal_set_type(::nnext::DataType value);
  public:

  // bool is_primary = 2;
  void clear_is_primary();
  bool is_primary() const;
  void set_is_primary(bool value);
  private:
  bool _internal_is_primary() const;
  void _internal_set_is_primary(bool value);
  public:

  // bool is_indexed = 3;
  void clear_is_indexed();
  bool is_indexed() const;
  void set_is_indexed(bool value);
  private:
  bool _internal_is_indexed() const;
  void _internal_set_is_indexed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nnext.SchemaItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int type_;
  bool is_primary_;
  bool is_indexed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class Schema_SchemaMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Schema_SchemaMapEntry_DoNotUse, 
    std::string, ::nnext::SchemaItem,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Schema_SchemaMapEntry_DoNotUse, 
    std::string, ::nnext::SchemaItem,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Schema_SchemaMapEntry_DoNotUse();
  explicit constexpr Schema_SchemaMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Schema_SchemaMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Schema_SchemaMapEntry_DoNotUse& other);
  static const Schema_SchemaMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Schema_SchemaMapEntry_DoNotUse*>(&_Schema_SchemaMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nnext.Schema.SchemaMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Schema final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.Schema) */ {
 public:
  inline Schema() : Schema(nullptr) {}
  ~Schema() override;
  explicit constexpr Schema(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Schema(const Schema& from);
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  inline Schema& operator=(Schema&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Schema& default_instance() {
    return *internal_default_instance();
  }
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }
  inline void Swap(Schema* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Schema* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Schema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Schema& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Schema& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.Schema";
  }
  protected:
  explicit Schema(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSchemaMapFieldNumber = 1,
    kRptdSchemaItemFieldNumber = 2,
  };
  // map<string, .nnext.SchemaItem> schema_map = 1;
  int schema_map_size() const;
  private:
  int _internal_schema_map_size() const;
  public:
  void clear_schema_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::SchemaItem >&
      _internal_schema_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::SchemaItem >*
      _internal_mutable_schema_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::SchemaItem >&
      schema_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::SchemaItem >*
      mutable_schema_map();

  // repeated .nnext.SchemaItem rptd__schema_item = 2;
  int rptd__schema_item_size() const;
  private:
  int _internal_rptd__schema_item_size() const;
  public:
  void clear_rptd__schema_item();
  ::nnext::SchemaItem* mutable_rptd__schema_item(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::SchemaItem >*
      mutable_rptd__schema_item();
  private:
  const ::nnext::SchemaItem& _internal_rptd__schema_item(int index) const;
  ::nnext::SchemaItem* _internal_add_rptd__schema_item();
  public:
  const ::nnext::SchemaItem& rptd__schema_item(int index) const;
  ::nnext::SchemaItem* add_rptd__schema_item();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::SchemaItem >&
      rptd__schema_item() const;

  // @@protoc_insertion_point(class_scope:nnext.Schema)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Schema_SchemaMapEntry_DoNotUse,
      std::string, ::nnext::SchemaItem,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> schema_map_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::SchemaItem > rptd__schema_item_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class Datum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.Datum) */ {
 public:
  inline Datum() : Datum(nullptr) {}
  ~Datum() override;
  explicit constexpr Datum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Datum(const Datum& from);
  Datum(Datum&& from) noexcept
    : Datum() {
    *this = ::std::move(from);
  }

  inline Datum& operator=(const Datum& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datum& operator=(Datum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Datum& default_instance() {
    return *internal_default_instance();
  }
  static inline const Datum* internal_default_instance() {
    return reinterpret_cast<const Datum*>(
               &_Datum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Datum& a, Datum& b) {
    a.Swap(&b);
  }
  inline void Swap(Datum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Datum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Datum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Datum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Datum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Datum& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.Datum";
  }
  protected:
  explicit Datum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRptdVectorFieldNumber = 2,
    kRptdMetadataFieldNumber = 3,
    kIdFieldNumber = 1,
  };
  // repeated float rptd__vector = 2;
  int rptd__vector_size() const;
  private:
  int _internal_rptd__vector_size() const;
  public:
  void clear_rptd__vector();
  private:
  float _internal_rptd__vector(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_rptd__vector() const;
  void _internal_add_rptd__vector(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_rptd__vector();
  public:
  float rptd__vector(int index) const;
  void set_rptd__vector(int index, float value);
  void add_rptd__vector(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      rptd__vector() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_rptd__vector();

  // repeated .nnext.Metadata rptd__metadata = 3;
  int rptd__metadata_size() const;
  private:
  int _internal_rptd__metadata_size() const;
  public:
  void clear_rptd__metadata();
  ::nnext::Metadata* mutable_rptd__metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Metadata >*
      mutable_rptd__metadata();
  private:
  const ::nnext::Metadata& _internal_rptd__metadata(int index) const;
  ::nnext::Metadata* _internal_add_rptd__metadata();
  public:
  const ::nnext::Metadata& rptd__metadata(int index) const;
  ::nnext::Metadata* add_rptd__metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Metadata >&
      rptd__metadata() const;

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:nnext.Datum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > rptd__vector_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Metadata > rptd__metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class DataList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.DataList) */ {
 public:
  inline DataList() : DataList(nullptr) {}
  ~DataList() override;
  explicit constexpr DataList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataList(const DataList& from);
  DataList(DataList&& from) noexcept
    : DataList() {
    *this = ::std::move(from);
  }

  inline DataList& operator=(const DataList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataList& operator=(DataList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataList* internal_default_instance() {
    return reinterpret_cast<const DataList*>(
               &_DataList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DataList& a, DataList& b) {
    a.Swap(&b);
  }
  inline void Swap(DataList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.DataList";
  }
  protected:
  explicit DataList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated float data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  float _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_data() const;
  void _internal_add_data(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_data();
  public:
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:nnext.DataList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class Vector final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() override;
  explicit constexpr Vector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector(const Vector& from);
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  inline void Swap(Vector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vector& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vector& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.Vector";
  }
  protected:
  explicit Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRptdElementFieldNumber = 1,
  };
  // repeated float rptd__element = 1;
  int rptd__element_size() const;
  private:
  int _internal_rptd__element_size() const;
  public:
  void clear_rptd__element();
  private:
  float _internal_rptd__element(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_rptd__element() const;
  void _internal_add_rptd__element(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_rptd__element();
  public:
  float rptd__element(int index) const;
  void set_rptd__element(int index, float value);
  void add_rptd__element(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      rptd__element() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_rptd__element();

  // @@protoc_insertion_point(class_scope:nnext.Vector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > rptd__element_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorList) */ {
 public:
  inline VectorList() : VectorList(nullptr) {}
  ~VectorList() override;
  explicit constexpr VectorList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorList(const VectorList& from);
  VectorList(VectorList&& from) noexcept
    : VectorList() {
    *this = ::std::move(from);
  }

  inline VectorList& operator=(const VectorList& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorList& operator=(VectorList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorList& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorList* internal_default_instance() {
    return reinterpret_cast<const VectorList*>(
               &_VectorList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(VectorList& a, VectorList& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorList";
  }
  protected:
  explicit VectorList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRptdVectorFieldNumber = 1,
  };
  // repeated .nnext.Vector rptd__vector = 1;
  int rptd__vector_size() const;
  private:
  int _internal_rptd__vector_size() const;
  public:
  void clear_rptd__vector();
  ::nnext::Vector* mutable_rptd__vector(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Vector >*
      mutable_rptd__vector();
  private:
  const ::nnext::Vector& _internal_rptd__vector(int index) const;
  ::nnext::Vector* _internal_add_rptd__vector();
  public:
  const ::nnext::Vector& rptd__vector(int index) const;
  ::nnext::Vector* add_rptd__vector();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Vector >&
      rptd__vector() const;

  // @@protoc_insertion_point(class_scope:nnext.VectorList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Vector > rptd__vector_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class Index final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.Index) */ {
 public:
  inline Index() : Index(nullptr) {}
  ~Index() override;
  explicit constexpr Index(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Index(const Index& from);
  Index(Index&& from) noexcept
    : Index() {
    *this = ::std::move(from);
  }

  inline Index& operator=(const Index& from) {
    CopyFrom(from);
    return *this;
  }
  inline Index& operator=(Index&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Index& default_instance() {
    return *internal_default_instance();
  }
  static inline const Index* internal_default_instance() {
    return reinterpret_cast<const Index*>(
               &_Index_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Index& a, Index& b) {
    a.Swap(&b);
  }
  inline void Swap(Index* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Index* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Index* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Index>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Index& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Index& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Index* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.Index";
  }
  protected:
  explicit Index(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSchemaFieldNumber = 7,
    kDimsFieldNumber = 2,
    kIndexTypeFieldNumber = 3,
    kMetricFieldNumber = 4,
    kIsTrainedFieldNumber = 5,
    kNtotalFieldNumber = 6,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .nnext.Schema schema = 7;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const ::nnext::Schema& schema() const;
  PROTOBUF_NODISCARD ::nnext::Schema* release_schema();
  ::nnext::Schema* mutable_schema();
  void set_allocated_schema(::nnext::Schema* schema);
  private:
  const ::nnext::Schema& _internal_schema() const;
  ::nnext::Schema* _internal_mutable_schema();
  public:
  void unsafe_arena_set_allocated_schema(
      ::nnext::Schema* schema);
  ::nnext::Schema* unsafe_arena_release_schema();

  // uint32 dims = 2;
  void clear_dims();
  uint32_t dims() const;
  void set_dims(uint32_t value);
  private:
  uint32_t _internal_dims() const;
  void _internal_set_dims(uint32_t value);
  public:

  // optional .nnext.IndexType index_type = 3;
  bool has_index_type() const;
  private:
  bool _internal_has_index_type() const;
  public:
  void clear_index_type();
  ::nnext::IndexType index_type() const;
  void set_index_type(::nnext::IndexType value);
  private:
  ::nnext::IndexType _internal_index_type() const;
  void _internal_set_index_type(::nnext::IndexType value);
  public:

  // optional .nnext.MetricType metric = 4;
  bool has_metric() const;
  private:
  bool _internal_has_metric() const;
  public:
  void clear_metric();
  ::nnext::MetricType metric() const;
  void set_metric(::nnext::MetricType value);
  private:
  ::nnext::MetricType _internal_metric() const;
  void _internal_set_metric(::nnext::MetricType value);
  public:

  // bool is_trained = 5;
  void clear_is_trained();
  bool is_trained() const;
  void set_is_trained(bool value);
  private:
  bool _internal_is_trained() const;
  void _internal_set_is_trained(bool value);
  public:

  // uint64 ntotal = 6;
  void clear_ntotal();
  uint64_t ntotal() const;
  void set_ntotal(uint64_t value);
  private:
  uint64_t _internal_ntotal() const;
  void _internal_set_ntotal(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:nnext.Index)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::nnext::Schema* schema_;
  uint32_t dims_;
  int index_type_;
  int metric_;
  bool is_trained_;
  uint64_t ntotal_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class IndexList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.IndexList) */ {
 public:
  inline IndexList() : IndexList(nullptr) {}
  ~IndexList() override;
  explicit constexpr IndexList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexList(const IndexList& from);
  IndexList(IndexList&& from) noexcept
    : IndexList() {
    *this = ::std::move(from);
  }

  inline IndexList& operator=(const IndexList& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexList& operator=(IndexList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexList& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexList* internal_default_instance() {
    return reinterpret_cast<const IndexList*>(
               &_IndexList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(IndexList& a, IndexList& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IndexList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.IndexList";
  }
  protected:
  explicit IndexList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndicesFieldNumber = 1,
  };
  // repeated .nnext.Index indices = 1;
  int indices_size() const;
  private:
  int _internal_indices_size() const;
  public:
  void clear_indices();
  ::nnext::Index* mutable_indices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Index >*
      mutable_indices();
  private:
  const ::nnext::Index& _internal_indices(int index) const;
  ::nnext::Index* _internal_add_indices();
  public:
  const ::nnext::Index& indices(int index) const;
  ::nnext::Index* add_indices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Index >&
      indices() const;

  // @@protoc_insertion_point(class_scope:nnext.IndexList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Index > indices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class IndexMap_IndicesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IndexMap_IndicesEntry_DoNotUse, 
    std::string, ::nnext::Index,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IndexMap_IndicesEntry_DoNotUse, 
    std::string, ::nnext::Index,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  IndexMap_IndicesEntry_DoNotUse();
  explicit constexpr IndexMap_IndicesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit IndexMap_IndicesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const IndexMap_IndicesEntry_DoNotUse& other);
  static const IndexMap_IndicesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const IndexMap_IndicesEntry_DoNotUse*>(&_IndexMap_IndicesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nnext.IndexMap.IndicesEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class IndexMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.IndexMap) */ {
 public:
  inline IndexMap() : IndexMap(nullptr) {}
  ~IndexMap() override;
  explicit constexpr IndexMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IndexMap(const IndexMap& from);
  IndexMap(IndexMap&& from) noexcept
    : IndexMap() {
    *this = ::std::move(from);
  }

  inline IndexMap& operator=(const IndexMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline IndexMap& operator=(IndexMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IndexMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const IndexMap* internal_default_instance() {
    return reinterpret_cast<const IndexMap*>(
               &_IndexMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(IndexMap& a, IndexMap& b) {
    a.Swap(&b);
  }
  inline void Swap(IndexMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IndexMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IndexMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IndexMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IndexMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IndexMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.IndexMap";
  }
  protected:
  explicit IndexMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kIndicesFieldNumber = 1,
  };
  // map<string, .nnext.Index> indices = 1;
  int indices_size() const;
  private:
  int _internal_indices_size() const;
  public:
  void clear_indices();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::Index >&
      _internal_indices() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::Index >*
      _internal_mutable_indices();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::Index >&
      indices() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::Index >*
      mutable_indices();

  // @@protoc_insertion_point(class_scope:nnext.IndexMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      IndexMap_IndicesEntry_DoNotUse,
      std::string, ::nnext::Index,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> indices_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class IdMap_IdxEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IdMap_IdxEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IdMap_IdxEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  IdMap_IdxEntry_DoNotUse();
  explicit constexpr IdMap_IdxEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit IdMap_IdxEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const IdMap_IdxEntry_DoNotUse& other);
  static const IdMap_IdxEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const IdMap_IdxEntry_DoNotUse*>(&_IdMap_IdxEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nnext.IdMap.IdxEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class IdMap_InvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IdMap_InvEntry_DoNotUse, 
    int64_t, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<IdMap_InvEntry_DoNotUse, 
    int64_t, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  IdMap_InvEntry_DoNotUse();
  explicit constexpr IdMap_InvEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit IdMap_InvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const IdMap_InvEntry_DoNotUse& other);
  static const IdMap_InvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const IdMap_InvEntry_DoNotUse*>(&_IdMap_InvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "nnext.IdMap.InvEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class IdMap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.IdMap) */ {
 public:
  inline IdMap() : IdMap(nullptr) {}
  ~IdMap() override;
  explicit constexpr IdMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IdMap(const IdMap& from);
  IdMap(IdMap&& from) noexcept
    : IdMap() {
    *this = ::std::move(from);
  }

  inline IdMap& operator=(const IdMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline IdMap& operator=(IdMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IdMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const IdMap* internal_default_instance() {
    return reinterpret_cast<const IdMap*>(
               &_IdMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(IdMap& a, IdMap& b) {
    a.Swap(&b);
  }
  inline void Swap(IdMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IdMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IdMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IdMap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IdMap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IdMap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IdMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.IdMap";
  }
  protected:
  explicit IdMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kIdxFieldNumber = 1,
    kInvFieldNumber = 2,
  };
  // map<string, int64> idx = 1;
  int idx_size() const;
  private:
  int _internal_idx_size() const;
  public:
  void clear_idx();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_idx() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_idx();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      idx() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_idx();

  // map<int64, string> inv = 2;
  int inv_size() const;
  private:
  int _internal_inv_size() const;
  public:
  void clear_inv();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >&
      _internal_inv() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >*
      _internal_mutable_inv();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >&
      inv() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >*
      mutable_inv();

  // @@protoc_insertion_point(class_scope:nnext.IdMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      IdMap_IdxEntry_DoNotUse,
      std::string, int64_t,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> idx_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      IdMap_InvEntry_DoNotUse,
      int64_t, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> inv_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class CreateIndexRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.CreateIndexRequest) */ {
 public:
  inline CreateIndexRequest() : CreateIndexRequest(nullptr) {}
  ~CreateIndexRequest() override;
  explicit constexpr CreateIndexRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateIndexRequest(const CreateIndexRequest& from);
  CreateIndexRequest(CreateIndexRequest&& from) noexcept
    : CreateIndexRequest() {
    *this = ::std::move(from);
  }

  inline CreateIndexRequest& operator=(const CreateIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIndexRequest& operator=(CreateIndexRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIndexRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIndexRequest* internal_default_instance() {
    return reinterpret_cast<const CreateIndexRequest*>(
               &_CreateIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CreateIndexRequest& a, CreateIndexRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIndexRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIndexRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIndexRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateIndexRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateIndexRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateIndexRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIndexRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.CreateIndexRequest";
  }
  protected:
  explicit CreateIndexRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSchemaFieldNumber = 5,
    kDimsFieldNumber = 2,
    kIndexTypeFieldNumber = 3,
    kMetricTypeFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string schema = 5;
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  // int32 dims = 2;
  void clear_dims();
  int32_t dims() const;
  void set_dims(int32_t value);
  private:
  int32_t _internal_dims() const;
  void _internal_set_dims(int32_t value);
  public:

  // .nnext.IndexType index_type = 3;
  void clear_index_type();
  ::nnext::IndexType index_type() const;
  void set_index_type(::nnext::IndexType value);
  private:
  ::nnext::IndexType _internal_index_type() const;
  void _internal_set_index_type(::nnext::IndexType value);
  public:

  // .nnext.MetricType metric_type = 4;
  void clear_metric_type();
  ::nnext::MetricType metric_type() const;
  void set_metric_type(::nnext::MetricType value);
  private:
  ::nnext::MetricType _internal_metric_type() const;
  void _internal_set_metric_type(::nnext::MetricType value);
  public:

  // @@protoc_insertion_point(class_scope:nnext.CreateIndexRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
  int32_t dims_;
  int index_type_;
  int metric_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class CreateIndexResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.CreateIndexResponse) */ {
 public:
  inline CreateIndexResponse() : CreateIndexResponse(nullptr) {}
  ~CreateIndexResponse() override;
  explicit constexpr CreateIndexResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateIndexResponse(const CreateIndexResponse& from);
  CreateIndexResponse(CreateIndexResponse&& from) noexcept
    : CreateIndexResponse() {
    *this = ::std::move(from);
  }

  inline CreateIndexResponse& operator=(const CreateIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateIndexResponse& operator=(CreateIndexResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateIndexResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateIndexResponse* internal_default_instance() {
    return reinterpret_cast<const CreateIndexResponse*>(
               &_CreateIndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CreateIndexResponse& a, CreateIndexResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateIndexResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateIndexResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateIndexResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateIndexResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateIndexResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateIndexResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateIndexResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.CreateIndexResponse";
  }
  protected:
  explicit CreateIndexResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // .nnext.Index index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  const ::nnext::Index& index() const;
  PROTOBUF_NODISCARD ::nnext::Index* release_index();
  ::nnext::Index* mutable_index();
  void set_allocated_index(::nnext::Index* index);
  private:
  const ::nnext::Index& _internal_index() const;
  ::nnext::Index* _internal_mutable_index();
  public:
  void unsafe_arena_set_allocated_index(
      ::nnext::Index* index);
  ::nnext::Index* unsafe_arena_release_index();

  // @@protoc_insertion_point(class_scope:nnext.CreateIndexResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::nnext::Index* index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class ListIndicesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.ListIndicesRequest) */ {
 public:
  inline ListIndicesRequest() : ListIndicesRequest(nullptr) {}
  ~ListIndicesRequest() override;
  explicit constexpr ListIndicesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListIndicesRequest(const ListIndicesRequest& from);
  ListIndicesRequest(ListIndicesRequest&& from) noexcept
    : ListIndicesRequest() {
    *this = ::std::move(from);
  }

  inline ListIndicesRequest& operator=(const ListIndicesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIndicesRequest& operator=(ListIndicesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIndicesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIndicesRequest* internal_default_instance() {
    return reinterpret_cast<const ListIndicesRequest*>(
               &_ListIndicesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ListIndicesRequest& a, ListIndicesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListIndicesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIndicesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIndicesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListIndicesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListIndicesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListIndicesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListIndicesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.ListIndicesRequest";
  }
  protected:
  explicit ListIndicesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPatternFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kSizeFieldNumber = 3,
    kDimsFieldNumber = 4,
  };
  // string pattern = 1;
  void clear_pattern();
  const std::string& pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pattern();
  PROTOBUF_NODISCARD std::string* release_pattern();
  void set_allocated_pattern(std::string* pattern);
  private:
  const std::string& _internal_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pattern(const std::string& value);
  std::string* _internal_mutable_pattern();
  public:

  // uint32 offset = 2;
  void clear_offset();
  uint32_t offset() const;
  void set_offset(uint32_t value);
  private:
  uint32_t _internal_offset() const;
  void _internal_set_offset(uint32_t value);
  public:

  // uint32 size = 3;
  void clear_size();
  uint32_t size() const;
  void set_size(uint32_t value);
  private:
  uint32_t _internal_size() const;
  void _internal_set_size(uint32_t value);
  public:

  // uint32 dims = 4;
  void clear_dims();
  uint32_t dims() const;
  void set_dims(uint32_t value);
  private:
  uint32_t _internal_dims() const;
  void _internal_set_dims(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:nnext.ListIndicesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pattern_;
  uint32_t offset_;
  uint32_t size_;
  uint32_t dims_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class ListIndicesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.ListIndicesResponse) */ {
 public:
  inline ListIndicesResponse() : ListIndicesResponse(nullptr) {}
  ~ListIndicesResponse() override;
  explicit constexpr ListIndicesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListIndicesResponse(const ListIndicesResponse& from);
  ListIndicesResponse(ListIndicesResponse&& from) noexcept
    : ListIndicesResponse() {
    *this = ::std::move(from);
  }

  inline ListIndicesResponse& operator=(const ListIndicesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListIndicesResponse& operator=(ListIndicesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListIndicesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListIndicesResponse* internal_default_instance() {
    return reinterpret_cast<const ListIndicesResponse*>(
               &_ListIndicesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListIndicesResponse& a, ListIndicesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListIndicesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListIndicesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListIndicesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListIndicesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListIndicesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListIndicesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListIndicesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.ListIndicesResponse";
  }
  protected:
  explicit ListIndicesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndicesFieldNumber = 1,
    kTotalFieldNumber = 2,
  };
  // repeated .nnext.Index indices = 1;
  int indices_size() const;
  private:
  int _internal_indices_size() const;
  public:
  void clear_indices();
  ::nnext::Index* mutable_indices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Index >*
      mutable_indices();
  private:
  const ::nnext::Index& _internal_indices(int index) const;
  ::nnext::Index* _internal_add_indices();
  public:
  const ::nnext::Index& indices(int index) const;
  ::nnext::Index* add_indices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Index >&
      indices() const;

  // uint32 total = 2;
  void clear_total();
  uint32_t total() const;
  void set_total(uint32_t value);
  private:
  uint32_t _internal_total() const;
  void _internal_set_total(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:nnext.ListIndicesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Index > indices_;
  uint32_t total_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class DropIndexRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.DropIndexRequest) */ {
 public:
  inline DropIndexRequest() : DropIndexRequest(nullptr) {}
  ~DropIndexRequest() override;
  explicit constexpr DropIndexRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropIndexRequest(const DropIndexRequest& from);
  DropIndexRequest(DropIndexRequest&& from) noexcept
    : DropIndexRequest() {
    *this = ::std::move(from);
  }

  inline DropIndexRequest& operator=(const DropIndexRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropIndexRequest& operator=(DropIndexRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropIndexRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropIndexRequest* internal_default_instance() {
    return reinterpret_cast<const DropIndexRequest*>(
               &_DropIndexRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DropIndexRequest& a, DropIndexRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropIndexRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropIndexRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropIndexRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropIndexRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropIndexRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DropIndexRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropIndexRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.DropIndexRequest";
  }
  protected:
  explicit DropIndexRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:nnext.DropIndexRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class DropIndexResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.DropIndexResponse) */ {
 public:
  inline DropIndexResponse() : DropIndexResponse(nullptr) {}
  ~DropIndexResponse() override;
  explicit constexpr DropIndexResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropIndexResponse(const DropIndexResponse& from);
  DropIndexResponse(DropIndexResponse&& from) noexcept
    : DropIndexResponse() {
    *this = ::std::move(from);
  }

  inline DropIndexResponse& operator=(const DropIndexResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropIndexResponse& operator=(DropIndexResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropIndexResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropIndexResponse* internal_default_instance() {
    return reinterpret_cast<const DropIndexResponse*>(
               &_DropIndexResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DropIndexResponse& a, DropIndexResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DropIndexResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropIndexResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropIndexResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropIndexResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropIndexResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DropIndexResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropIndexResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.DropIndexResponse";
  }
  protected:
  explicit DropIndexResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // .nnext.Index index = 1;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  const ::nnext::Index& index() const;
  PROTOBUF_NODISCARD ::nnext::Index* release_index();
  ::nnext::Index* mutable_index();
  void set_allocated_index(::nnext::Index* index);
  private:
  const ::nnext::Index& _internal_index() const;
  ::nnext::Index* _internal_mutable_index();
  public:
  void unsafe_arena_set_allocated_index(
      ::nnext::Index* index);
  ::nnext::Index* unsafe_arena_release_index();

  // @@protoc_insertion_point(class_scope:nnext.DropIndexResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::nnext::Index* index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorAddRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorAddRequest) */ {
 public:
  inline VectorAddRequest() : VectorAddRequest(nullptr) {}
  ~VectorAddRequest() override;
  explicit constexpr VectorAddRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorAddRequest(const VectorAddRequest& from);
  VectorAddRequest(VectorAddRequest&& from) noexcept
    : VectorAddRequest() {
    *this = ::std::move(from);
  }

  inline VectorAddRequest& operator=(const VectorAddRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorAddRequest& operator=(VectorAddRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorAddRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorAddRequest* internal_default_instance() {
    return reinterpret_cast<const VectorAddRequest*>(
               &_VectorAddRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(VectorAddRequest& a, VectorAddRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorAddRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorAddRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorAddRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorAddRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorAddRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorAddRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorAddRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorAddRequest";
  }
  protected:
  explicit VectorAddRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kIndexNameFieldNumber = 1,
    kHeaderColsFieldNumber = 2,
    kHeaderTypesFieldNumber = 3,
  };
  // repeated .nnext.Datum data = 4;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::nnext::Datum* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
      mutable_data();
  private:
  const ::nnext::Datum& _internal_data(int index) const;
  ::nnext::Datum* _internal_add_data();
  public:
  const ::nnext::Datum& data(int index) const;
  ::nnext::Datum* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
      data() const;

  // string index_name = 1;
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_NODISCARD std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // string header_cols = 2;
  void clear_header_cols();
  const std::string& header_cols() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_header_cols(ArgT0&& arg0, ArgT... args);
  std::string* mutable_header_cols();
  PROTOBUF_NODISCARD std::string* release_header_cols();
  void set_allocated_header_cols(std::string* header_cols);
  private:
  const std::string& _internal_header_cols() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header_cols(const std::string& value);
  std::string* _internal_mutable_header_cols();
  public:

  // string header_types = 3;
  void clear_header_types();
  const std::string& header_types() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_header_types(ArgT0&& arg0, ArgT... args);
  std::string* mutable_header_types();
  PROTOBUF_NODISCARD std::string* release_header_types();
  void set_allocated_header_types(std::string* header_types);
  private:
  const std::string& _internal_header_types() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header_types(const std::string& value);
  std::string* _internal_mutable_header_types();
  public:

  // @@protoc_insertion_point(class_scope:nnext.VectorAddRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_cols_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_types_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorAddResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorAddResponse) */ {
 public:
  inline VectorAddResponse() : VectorAddResponse(nullptr) {}
  ~VectorAddResponse() override;
  explicit constexpr VectorAddResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorAddResponse(const VectorAddResponse& from);
  VectorAddResponse(VectorAddResponse&& from) noexcept
    : VectorAddResponse() {
    *this = ::std::move(from);
  }

  inline VectorAddResponse& operator=(const VectorAddResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorAddResponse& operator=(VectorAddResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorAddResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorAddResponse* internal_default_instance() {
    return reinterpret_cast<const VectorAddResponse*>(
               &_VectorAddResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(VectorAddResponse& a, VectorAddResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorAddResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorAddResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorAddResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorAddResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorAddResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorAddResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorAddResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorAddResponse";
  }
  protected:
  explicit VectorAddResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kTotalFieldNumber = 2,
  };
  // repeated .nnext.Datum data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::nnext::Datum* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
      mutable_data();
  private:
  const ::nnext::Datum& _internal_data(int index) const;
  ::nnext::Datum* _internal_add_data();
  public:
  const ::nnext::Datum& data(int index) const;
  ::nnext::Datum* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
      data() const;

  // uint64 total = 2;
  void clear_total();
  uint64_t total() const;
  void set_total(uint64_t value);
  private:
  uint64_t _internal_total() const;
  void _internal_set_total(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:nnext.VectorAddResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum > data_;
  uint64_t total_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorSearchRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorSearchRequest) */ {
 public:
  inline VectorSearchRequest() : VectorSearchRequest(nullptr) {}
  ~VectorSearchRequest() override;
  explicit constexpr VectorSearchRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorSearchRequest(const VectorSearchRequest& from);
  VectorSearchRequest(VectorSearchRequest&& from) noexcept
    : VectorSearchRequest() {
    *this = ::std::move(from);
  }

  inline VectorSearchRequest& operator=(const VectorSearchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorSearchRequest& operator=(VectorSearchRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorSearchRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorSearchRequest* internal_default_instance() {
    return reinterpret_cast<const VectorSearchRequest*>(
               &_VectorSearchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(VectorSearchRequest& a, VectorSearchRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorSearchRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorSearchRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorSearchRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorSearchRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorSearchRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorSearchRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorSearchRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorSearchRequest";
  }
  protected:
  explicit VectorSearchRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRptdQueryVectorFieldNumber = 2,
    kIndexNameFieldNumber = 1,
    kFiltersFieldNumber = 4,
    kKFieldNumber = 3,
    kOmitVectorFieldNumber = 5,
    kOmitMetadataFieldNumber = 6,
  };
  // repeated .nnext.Vector rptd_query_vector = 2;
  int rptd_query_vector_size() const;
  private:
  int _internal_rptd_query_vector_size() const;
  public:
  void clear_rptd_query_vector();
  ::nnext::Vector* mutable_rptd_query_vector(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Vector >*
      mutable_rptd_query_vector();
  private:
  const ::nnext::Vector& _internal_rptd_query_vector(int index) const;
  ::nnext::Vector* _internal_add_rptd_query_vector();
  public:
  const ::nnext::Vector& rptd_query_vector(int index) const;
  ::nnext::Vector* add_rptd_query_vector();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Vector >&
      rptd_query_vector() const;

  // string index_name = 1;
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_NODISCARD std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // string filters = 4;
  void clear_filters();
  const std::string& filters() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filters(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filters();
  PROTOBUF_NODISCARD std::string* release_filters();
  void set_allocated_filters(std::string* filters);
  private:
  const std::string& _internal_filters() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filters(const std::string& value);
  std::string* _internal_mutable_filters();
  public:

  // uint32 k = 3;
  void clear_k();
  uint32_t k() const;
  void set_k(uint32_t value);
  private:
  uint32_t _internal_k() const;
  void _internal_set_k(uint32_t value);
  public:

  // bool omit_vector = 5;
  void clear_omit_vector();
  bool omit_vector() const;
  void set_omit_vector(bool value);
  private:
  bool _internal_omit_vector() const;
  void _internal_set_omit_vector(bool value);
  public:

  // bool omit_metadata = 6;
  void clear_omit_metadata();
  bool omit_metadata() const;
  void set_omit_metadata(bool value);
  private:
  bool _internal_omit_metadata() const;
  void _internal_set_omit_metadata(bool value);
  public:

  // @@protoc_insertion_point(class_scope:nnext.VectorSearchRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Vector > rptd_query_vector_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filters_;
  uint32_t k_;
  bool omit_vector_;
  bool omit_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorSearchResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorSearchResponse) */ {
 public:
  inline VectorSearchResponse() : VectorSearchResponse(nullptr) {}
  ~VectorSearchResponse() override;
  explicit constexpr VectorSearchResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorSearchResponse(const VectorSearchResponse& from);
  VectorSearchResponse(VectorSearchResponse&& from) noexcept
    : VectorSearchResponse() {
    *this = ::std::move(from);
  }

  inline VectorSearchResponse& operator=(const VectorSearchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorSearchResponse& operator=(VectorSearchResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorSearchResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorSearchResponse* internal_default_instance() {
    return reinterpret_cast<const VectorSearchResponse*>(
               &_VectorSearchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(VectorSearchResponse& a, VectorSearchResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorSearchResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorSearchResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorSearchResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorSearchResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorSearchResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorSearchResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorSearchResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorSearchResponse";
  }
  protected:
  explicit VectorSearchResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRptdDatumFieldNumber = 3,
    kPageFieldNumber = 1,
    kNtotalFieldNumber = 2,
  };
  // repeated .nnext.Datum rptd__datum = 3;
  int rptd__datum_size() const;
  private:
  int _internal_rptd__datum_size() const;
  public:
  void clear_rptd__datum();
  ::nnext::Datum* mutable_rptd__datum(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
      mutable_rptd__datum();
  private:
  const ::nnext::Datum& _internal_rptd__datum(int index) const;
  ::nnext::Datum* _internal_add_rptd__datum();
  public:
  const ::nnext::Datum& rptd__datum(int index) const;
  ::nnext::Datum* add_rptd__datum();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
      rptd__datum() const;

  // string page = 1;
  void clear_page();
  const std::string& page() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page();
  PROTOBUF_NODISCARD std::string* release_page();
  void set_allocated_page(std::string* page);
  private:
  const std::string& _internal_page() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page(const std::string& value);
  std::string* _internal_mutable_page();
  public:

  // uint64 ntotal = 2;
  void clear_ntotal();
  uint64_t ntotal() const;
  void set_ntotal(uint64_t value);
  private:
  uint64_t _internal_ntotal() const;
  void _internal_set_ntotal(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:nnext.VectorSearchResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum > rptd__datum_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_;
  uint64_t ntotal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorGetRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorGetRequest) */ {
 public:
  inline VectorGetRequest() : VectorGetRequest(nullptr) {}
  ~VectorGetRequest() override;
  explicit constexpr VectorGetRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorGetRequest(const VectorGetRequest& from);
  VectorGetRequest(VectorGetRequest&& from) noexcept
    : VectorGetRequest() {
    *this = ::std::move(from);
  }

  inline VectorGetRequest& operator=(const VectorGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorGetRequest& operator=(VectorGetRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorGetRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorGetRequest* internal_default_instance() {
    return reinterpret_cast<const VectorGetRequest*>(
               &_VectorGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(VectorGetRequest& a, VectorGetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorGetRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorGetRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorGetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorGetRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorGetRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorGetRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorGetRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorGetRequest";
  }
  protected:
  explicit VectorGetRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kIndexNameFieldNumber = 2,
  };
  // repeated .nnext.Datum data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::nnext::Datum* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
      mutable_data();
  private:
  const ::nnext::Datum& _internal_data(int index) const;
  ::nnext::Datum* _internal_add_data();
  public:
  const ::nnext::Datum& data(int index) const;
  ::nnext::Datum* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
      data() const;

  // string index_name = 2;
  void clear_index_name();
  const std::string& index_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_index_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_index_name();
  PROTOBUF_NODISCARD std::string* release_index_name();
  void set_allocated_index_name(std::string* index_name);
  private:
  const std::string& _internal_index_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_index_name(const std::string& value);
  std::string* _internal_mutable_index_name();
  public:

  // @@protoc_insertion_point(class_scope:nnext.VectorGetRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum > data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorGetResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorGetResponse) */ {
 public:
  inline VectorGetResponse() : VectorGetResponse(nullptr) {}
  ~VectorGetResponse() override;
  explicit constexpr VectorGetResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorGetResponse(const VectorGetResponse& from);
  VectorGetResponse(VectorGetResponse&& from) noexcept
    : VectorGetResponse() {
    *this = ::std::move(from);
  }

  inline VectorGetResponse& operator=(const VectorGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorGetResponse& operator=(VectorGetResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorGetResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorGetResponse* internal_default_instance() {
    return reinterpret_cast<const VectorGetResponse*>(
               &_VectorGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(VectorGetResponse& a, VectorGetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorGetResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorGetResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorGetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorGetResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorGetResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorGetResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorGetResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorGetResponse";
  }
  protected:
  explicit VectorGetResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
  };
  // repeated .nnext.Datum data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::nnext::Datum* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
      mutable_data();
  private:
  const ::nnext::Datum& _internal_data(int index) const;
  ::nnext::Datum* _internal_add_data();
  public:
  const ::nnext::Datum& data(int index) const;
  ::nnext::Datum* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
      data() const;

  // @@protoc_insertion_point(class_scope:nnext.VectorGetResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorDeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorDeleteRequest) */ {
 public:
  inline VectorDeleteRequest() : VectorDeleteRequest(nullptr) {}
  ~VectorDeleteRequest() override;
  explicit constexpr VectorDeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorDeleteRequest(const VectorDeleteRequest& from);
  VectorDeleteRequest(VectorDeleteRequest&& from) noexcept
    : VectorDeleteRequest() {
    *this = ::std::move(from);
  }

  inline VectorDeleteRequest& operator=(const VectorDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorDeleteRequest& operator=(VectorDeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorDeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorDeleteRequest* internal_default_instance() {
    return reinterpret_cast<const VectorDeleteRequest*>(
               &_VectorDeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(VectorDeleteRequest& a, VectorDeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorDeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorDeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorDeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorDeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorDeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorDeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorDeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorDeleteRequest";
  }
  protected:
  explicit VectorDeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .nnext.Datum data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::nnext::Datum* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
      mutable_data();
  private:
  const ::nnext::Datum& _internal_data(int index) const;
  ::nnext::Datum* _internal_add_data();
  public:
  const ::nnext::Datum& data(int index) const;
  ::nnext::Datum* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
      data() const;

  // @@protoc_insertion_point(class_scope:nnext.VectorDeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorDeleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorDeleteResponse) */ {
 public:
  inline VectorDeleteResponse() : VectorDeleteResponse(nullptr) {}
  ~VectorDeleteResponse() override;
  explicit constexpr VectorDeleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorDeleteResponse(const VectorDeleteResponse& from);
  VectorDeleteResponse(VectorDeleteResponse&& from) noexcept
    : VectorDeleteResponse() {
    *this = ::std::move(from);
  }

  inline VectorDeleteResponse& operator=(const VectorDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorDeleteResponse& operator=(VectorDeleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorDeleteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorDeleteResponse* internal_default_instance() {
    return reinterpret_cast<const VectorDeleteResponse*>(
               &_VectorDeleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(VectorDeleteResponse& a, VectorDeleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorDeleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorDeleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorDeleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorDeleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorDeleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorDeleteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorDeleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorDeleteResponse";
  }
  protected:
  explicit VectorDeleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
  };
  // repeated .nnext.Datum data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::nnext::Datum* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
      mutable_data();
  private:
  const ::nnext::Datum& _internal_data(int index) const;
  ::nnext::Datum* _internal_add_data();
  public:
  const ::nnext::Datum& data(int index) const;
  ::nnext::Datum* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
      data() const;

  // @@protoc_insertion_point(class_scope:nnext.VectorDeleteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorClearRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorClearRequest) */ {
 public:
  inline VectorClearRequest() : VectorClearRequest(nullptr) {}
  ~VectorClearRequest() override;
  explicit constexpr VectorClearRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorClearRequest(const VectorClearRequest& from);
  VectorClearRequest(VectorClearRequest&& from) noexcept
    : VectorClearRequest() {
    *this = ::std::move(from);
  }

  inline VectorClearRequest& operator=(const VectorClearRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorClearRequest& operator=(VectorClearRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorClearRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorClearRequest* internal_default_instance() {
    return reinterpret_cast<const VectorClearRequest*>(
               &_VectorClearRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(VectorClearRequest& a, VectorClearRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorClearRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorClearRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorClearRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorClearRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorClearRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorClearRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorClearRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorClearRequest";
  }
  protected:
  explicit VectorClearRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // repeated .nnext.Datum data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::nnext::Datum* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
      mutable_data();
  private:
  const ::nnext::Datum& _internal_data(int index) const;
  ::nnext::Datum* _internal_add_data();
  public:
  const ::nnext::Datum& data(int index) const;
  ::nnext::Datum* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
      data() const;

  // @@protoc_insertion_point(class_scope:nnext.VectorClearRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// -------------------------------------------------------------------

class VectorClearResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:nnext.VectorClearResponse) */ {
 public:
  inline VectorClearResponse() : VectorClearResponse(nullptr) {}
  ~VectorClearResponse() override;
  explicit constexpr VectorClearResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VectorClearResponse(const VectorClearResponse& from);
  VectorClearResponse(VectorClearResponse&& from) noexcept
    : VectorClearResponse() {
    *this = ::std::move(from);
  }

  inline VectorClearResponse& operator=(const VectorClearResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VectorClearResponse& operator=(VectorClearResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VectorClearResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VectorClearResponse* internal_default_instance() {
    return reinterpret_cast<const VectorClearResponse*>(
               &_VectorClearResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(VectorClearResponse& a, VectorClearResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VectorClearResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VectorClearResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VectorClearResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VectorClearResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VectorClearResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VectorClearResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VectorClearResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "nnext.VectorClearResponse";
  }
  protected:
  explicit VectorClearResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
  };
  // repeated .nnext.Datum data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::nnext::Datum* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
      mutable_data();
  private:
  const ::nnext::Datum& _internal_data(int index) const;
  ::nnext::Datum* _internal_add_data();
  public:
  const ::nnext::Datum& data(int index) const;
  ::nnext::Datum* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
      data() const;

  // @@protoc_insertion_point(class_scope:nnext.VectorClearResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum > data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_main_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Metadata

// double _double = 1;
inline bool Metadata::_internal_has__double() const {
  return metafield_case() == kDouble;
}
inline bool Metadata::has__double() const {
  return _internal_has__double();
}
inline void Metadata::set_has__double() {
  _oneof_case_[0] = kDouble;
}
inline void Metadata::clear__double() {
  if (_internal_has__double()) {
    metafield_._double_ = 0;
    clear_has_metafield();
  }
}
inline double Metadata::_internal__double() const {
  if (_internal_has__double()) {
    return metafield_._double_;
  }
  return 0;
}
inline void Metadata::_internal_set__double(double value) {
  if (!_internal_has__double()) {
    clear_metafield();
    set_has__double();
  }
  metafield_._double_ = value;
}
inline double Metadata::_double() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._double)
  return _internal__double();
}
inline void Metadata::set__double(double value) {
  _internal_set__double(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._double)
}

// float _float = 2;
inline bool Metadata::_internal_has__float() const {
  return metafield_case() == kFloat;
}
inline bool Metadata::has__float() const {
  return _internal_has__float();
}
inline void Metadata::set_has__float() {
  _oneof_case_[0] = kFloat;
}
inline void Metadata::clear__float() {
  if (_internal_has__float()) {
    metafield_._float_ = 0;
    clear_has_metafield();
  }
}
inline float Metadata::_internal__float() const {
  if (_internal_has__float()) {
    return metafield_._float_;
  }
  return 0;
}
inline void Metadata::_internal_set__float(float value) {
  if (!_internal_has__float()) {
    clear_metafield();
    set_has__float();
  }
  metafield_._float_ = value;
}
inline float Metadata::_float() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._float)
  return _internal__float();
}
inline void Metadata::set__float(float value) {
  _internal_set__float(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._float)
}

// int32 _int32 = 3;
inline bool Metadata::_internal_has__int32() const {
  return metafield_case() == kInt32;
}
inline bool Metadata::has__int32() const {
  return _internal_has__int32();
}
inline void Metadata::set_has__int32() {
  _oneof_case_[0] = kInt32;
}
inline void Metadata::clear__int32() {
  if (_internal_has__int32()) {
    metafield_._int32_ = 0;
    clear_has_metafield();
  }
}
inline int32_t Metadata::_internal__int32() const {
  if (_internal_has__int32()) {
    return metafield_._int32_;
  }
  return 0;
}
inline void Metadata::_internal_set__int32(int32_t value) {
  if (!_internal_has__int32()) {
    clear_metafield();
    set_has__int32();
  }
  metafield_._int32_ = value;
}
inline int32_t Metadata::_int32() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._int32)
  return _internal__int32();
}
inline void Metadata::set__int32(int32_t value) {
  _internal_set__int32(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._int32)
}

// int64 _int64 = 4;
inline bool Metadata::_internal_has__int64() const {
  return metafield_case() == kInt64;
}
inline bool Metadata::has__int64() const {
  return _internal_has__int64();
}
inline void Metadata::set_has__int64() {
  _oneof_case_[0] = kInt64;
}
inline void Metadata::clear__int64() {
  if (_internal_has__int64()) {
    metafield_._int64_ = int64_t{0};
    clear_has_metafield();
  }
}
inline int64_t Metadata::_internal__int64() const {
  if (_internal_has__int64()) {
    return metafield_._int64_;
  }
  return int64_t{0};
}
inline void Metadata::_internal_set__int64(int64_t value) {
  if (!_internal_has__int64()) {
    clear_metafield();
    set_has__int64();
  }
  metafield_._int64_ = value;
}
inline int64_t Metadata::_int64() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._int64)
  return _internal__int64();
}
inline void Metadata::set__int64(int64_t value) {
  _internal_set__int64(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._int64)
}

// uint32 _uint32 = 5;
inline bool Metadata::_internal_has__uint32() const {
  return metafield_case() == kUint32;
}
inline bool Metadata::has__uint32() const {
  return _internal_has__uint32();
}
inline void Metadata::set_has__uint32() {
  _oneof_case_[0] = kUint32;
}
inline void Metadata::clear__uint32() {
  if (_internal_has__uint32()) {
    metafield_._uint32_ = 0u;
    clear_has_metafield();
  }
}
inline uint32_t Metadata::_internal__uint32() const {
  if (_internal_has__uint32()) {
    return metafield_._uint32_;
  }
  return 0u;
}
inline void Metadata::_internal_set__uint32(uint32_t value) {
  if (!_internal_has__uint32()) {
    clear_metafield();
    set_has__uint32();
  }
  metafield_._uint32_ = value;
}
inline uint32_t Metadata::_uint32() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._uint32)
  return _internal__uint32();
}
inline void Metadata::set__uint32(uint32_t value) {
  _internal_set__uint32(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._uint32)
}

// uint64 _uint64 = 6;
inline bool Metadata::_internal_has__uint64() const {
  return metafield_case() == kUint64;
}
inline bool Metadata::has__uint64() const {
  return _internal_has__uint64();
}
inline void Metadata::set_has__uint64() {
  _oneof_case_[0] = kUint64;
}
inline void Metadata::clear__uint64() {
  if (_internal_has__uint64()) {
    metafield_._uint64_ = uint64_t{0u};
    clear_has_metafield();
  }
}
inline uint64_t Metadata::_internal__uint64() const {
  if (_internal_has__uint64()) {
    return metafield_._uint64_;
  }
  return uint64_t{0u};
}
inline void Metadata::_internal_set__uint64(uint64_t value) {
  if (!_internal_has__uint64()) {
    clear_metafield();
    set_has__uint64();
  }
  metafield_._uint64_ = value;
}
inline uint64_t Metadata::_uint64() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._uint64)
  return _internal__uint64();
}
inline void Metadata::set__uint64(uint64_t value) {
  _internal_set__uint64(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._uint64)
}

// sint32 _sint32 = 7;
inline bool Metadata::_internal_has__sint32() const {
  return metafield_case() == kSint32;
}
inline bool Metadata::has__sint32() const {
  return _internal_has__sint32();
}
inline void Metadata::set_has__sint32() {
  _oneof_case_[0] = kSint32;
}
inline void Metadata::clear__sint32() {
  if (_internal_has__sint32()) {
    metafield_._sint32_ = 0;
    clear_has_metafield();
  }
}
inline int32_t Metadata::_internal__sint32() const {
  if (_internal_has__sint32()) {
    return metafield_._sint32_;
  }
  return 0;
}
inline void Metadata::_internal_set__sint32(int32_t value) {
  if (!_internal_has__sint32()) {
    clear_metafield();
    set_has__sint32();
  }
  metafield_._sint32_ = value;
}
inline int32_t Metadata::_sint32() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._sint32)
  return _internal__sint32();
}
inline void Metadata::set__sint32(int32_t value) {
  _internal_set__sint32(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._sint32)
}

// sint64 _sint64 = 8;
inline bool Metadata::_internal_has__sint64() const {
  return metafield_case() == kSint64;
}
inline bool Metadata::has__sint64() const {
  return _internal_has__sint64();
}
inline void Metadata::set_has__sint64() {
  _oneof_case_[0] = kSint64;
}
inline void Metadata::clear__sint64() {
  if (_internal_has__sint64()) {
    metafield_._sint64_ = int64_t{0};
    clear_has_metafield();
  }
}
inline int64_t Metadata::_internal__sint64() const {
  if (_internal_has__sint64()) {
    return metafield_._sint64_;
  }
  return int64_t{0};
}
inline void Metadata::_internal_set__sint64(int64_t value) {
  if (!_internal_has__sint64()) {
    clear_metafield();
    set_has__sint64();
  }
  metafield_._sint64_ = value;
}
inline int64_t Metadata::_sint64() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._sint64)
  return _internal__sint64();
}
inline void Metadata::set__sint64(int64_t value) {
  _internal_set__sint64(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._sint64)
}

// fixed32 _fixed32 = 9;
inline bool Metadata::_internal_has__fixed32() const {
  return metafield_case() == kFixed32;
}
inline bool Metadata::has__fixed32() const {
  return _internal_has__fixed32();
}
inline void Metadata::set_has__fixed32() {
  _oneof_case_[0] = kFixed32;
}
inline void Metadata::clear__fixed32() {
  if (_internal_has__fixed32()) {
    metafield_._fixed32_ = 0u;
    clear_has_metafield();
  }
}
inline uint32_t Metadata::_internal__fixed32() const {
  if (_internal_has__fixed32()) {
    return metafield_._fixed32_;
  }
  return 0u;
}
inline void Metadata::_internal_set__fixed32(uint32_t value) {
  if (!_internal_has__fixed32()) {
    clear_metafield();
    set_has__fixed32();
  }
  metafield_._fixed32_ = value;
}
inline uint32_t Metadata::_fixed32() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._fixed32)
  return _internal__fixed32();
}
inline void Metadata::set__fixed32(uint32_t value) {
  _internal_set__fixed32(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._fixed32)
}

// fixed64 _fixed64 = 10;
inline bool Metadata::_internal_has__fixed64() const {
  return metafield_case() == kFixed64;
}
inline bool Metadata::has__fixed64() const {
  return _internal_has__fixed64();
}
inline void Metadata::set_has__fixed64() {
  _oneof_case_[0] = kFixed64;
}
inline void Metadata::clear__fixed64() {
  if (_internal_has__fixed64()) {
    metafield_._fixed64_ = uint64_t{0u};
    clear_has_metafield();
  }
}
inline uint64_t Metadata::_internal__fixed64() const {
  if (_internal_has__fixed64()) {
    return metafield_._fixed64_;
  }
  return uint64_t{0u};
}
inline void Metadata::_internal_set__fixed64(uint64_t value) {
  if (!_internal_has__fixed64()) {
    clear_metafield();
    set_has__fixed64();
  }
  metafield_._fixed64_ = value;
}
inline uint64_t Metadata::_fixed64() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._fixed64)
  return _internal__fixed64();
}
inline void Metadata::set__fixed64(uint64_t value) {
  _internal_set__fixed64(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._fixed64)
}

// sfixed32 _sfixed32 = 11;
inline bool Metadata::_internal_has__sfixed32() const {
  return metafield_case() == kSfixed32;
}
inline bool Metadata::has__sfixed32() const {
  return _internal_has__sfixed32();
}
inline void Metadata::set_has__sfixed32() {
  _oneof_case_[0] = kSfixed32;
}
inline void Metadata::clear__sfixed32() {
  if (_internal_has__sfixed32()) {
    metafield_._sfixed32_ = 0;
    clear_has_metafield();
  }
}
inline int32_t Metadata::_internal__sfixed32() const {
  if (_internal_has__sfixed32()) {
    return metafield_._sfixed32_;
  }
  return 0;
}
inline void Metadata::_internal_set__sfixed32(int32_t value) {
  if (!_internal_has__sfixed32()) {
    clear_metafield();
    set_has__sfixed32();
  }
  metafield_._sfixed32_ = value;
}
inline int32_t Metadata::_sfixed32() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._sfixed32)
  return _internal__sfixed32();
}
inline void Metadata::set__sfixed32(int32_t value) {
  _internal_set__sfixed32(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._sfixed32)
}

// sfixed64 _sfixed64 = 12;
inline bool Metadata::_internal_has__sfixed64() const {
  return metafield_case() == kSfixed64;
}
inline bool Metadata::has__sfixed64() const {
  return _internal_has__sfixed64();
}
inline void Metadata::set_has__sfixed64() {
  _oneof_case_[0] = kSfixed64;
}
inline void Metadata::clear__sfixed64() {
  if (_internal_has__sfixed64()) {
    metafield_._sfixed64_ = int64_t{0};
    clear_has_metafield();
  }
}
inline int64_t Metadata::_internal__sfixed64() const {
  if (_internal_has__sfixed64()) {
    return metafield_._sfixed64_;
  }
  return int64_t{0};
}
inline void Metadata::_internal_set__sfixed64(int64_t value) {
  if (!_internal_has__sfixed64()) {
    clear_metafield();
    set_has__sfixed64();
  }
  metafield_._sfixed64_ = value;
}
inline int64_t Metadata::_sfixed64() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._sfixed64)
  return _internal__sfixed64();
}
inline void Metadata::set__sfixed64(int64_t value) {
  _internal_set__sfixed64(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._sfixed64)
}

// bool _bool = 13;
inline bool Metadata::_internal_has__bool() const {
  return metafield_case() == kBool;
}
inline bool Metadata::has__bool() const {
  return _internal_has__bool();
}
inline void Metadata::set_has__bool() {
  _oneof_case_[0] = kBool;
}
inline void Metadata::clear__bool() {
  if (_internal_has__bool()) {
    metafield_._bool_ = false;
    clear_has_metafield();
  }
}
inline bool Metadata::_internal__bool() const {
  if (_internal_has__bool()) {
    return metafield_._bool_;
  }
  return false;
}
inline void Metadata::_internal_set__bool(bool value) {
  if (!_internal_has__bool()) {
    clear_metafield();
    set_has__bool();
  }
  metafield_._bool_ = value;
}
inline bool Metadata::_bool() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._bool)
  return _internal__bool();
}
inline void Metadata::set__bool(bool value) {
  _internal_set__bool(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata._bool)
}

// string _string = 14;
inline bool Metadata::_internal_has__string() const {
  return metafield_case() == kString;
}
inline bool Metadata::has__string() const {
  return _internal_has__string();
}
inline void Metadata::set_has__string() {
  _oneof_case_[0] = kString;
}
inline void Metadata::clear__string() {
  if (_internal_has__string()) {
    metafield_._string_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_metafield();
  }
}
inline const std::string& Metadata::_string() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._string)
  return _internal__string();
}
template <typename ArgT0, typename... ArgT>
inline void Metadata::set__string(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has__string()) {
    clear_metafield();
    set_has__string();
    metafield_._string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  metafield_._string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.Metadata._string)
}
inline std::string* Metadata::mutable__string() {
  std::string* _s = _internal_mutable__string();
  // @@protoc_insertion_point(field_mutable:nnext.Metadata._string)
  return _s;
}
inline const std::string& Metadata::_internal__string() const {
  if (_internal_has__string()) {
    return metafield_._string_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Metadata::_internal_set__string(const std::string& value) {
  if (!_internal_has__string()) {
    clear_metafield();
    set_has__string();
    metafield_._string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  metafield_._string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable__string() {
  if (!_internal_has__string()) {
    clear_metafield();
    set_has__string();
    metafield_._string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return metafield_._string_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Metadata::release__string() {
  // @@protoc_insertion_point(field_release:nnext.Metadata._string)
  if (_internal_has__string()) {
    clear_has_metafield();
    return metafield_._string_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Metadata::set_allocated__string(std::string* _string) {
  if (has_metafield()) {
    clear_metafield();
  }
  if (_string != nullptr) {
    set_has__string();
    metafield_._string_.UnsafeSetDefault(_string);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(_string);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:nnext.Metadata._string)
}

// bytes _bytes = 15;
inline bool Metadata::_internal_has__bytes() const {
  return metafield_case() == kBytes;
}
inline bool Metadata::has__bytes() const {
  return _internal_has__bytes();
}
inline void Metadata::set_has__bytes() {
  _oneof_case_[0] = kBytes;
}
inline void Metadata::clear__bytes() {
  if (_internal_has__bytes()) {
    metafield_._bytes_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_metafield();
  }
}
inline const std::string& Metadata::_bytes() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata._bytes)
  return _internal__bytes();
}
template <typename ArgT0, typename... ArgT>
inline void Metadata::set__bytes(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has__bytes()) {
    clear_metafield();
    set_has__bytes();
    metafield_._bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  metafield_._bytes_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.Metadata._bytes)
}
inline std::string* Metadata::mutable__bytes() {
  std::string* _s = _internal_mutable__bytes();
  // @@protoc_insertion_point(field_mutable:nnext.Metadata._bytes)
  return _s;
}
inline const std::string& Metadata::_internal__bytes() const {
  if (_internal_has__bytes()) {
    return metafield_._bytes_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Metadata::_internal_set__bytes(const std::string& value) {
  if (!_internal_has__bytes()) {
    clear_metafield();
    set_has__bytes();
    metafield_._bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  metafield_._bytes_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable__bytes() {
  if (!_internal_has__bytes()) {
    clear_metafield();
    set_has__bytes();
    metafield_._bytes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return metafield_._bytes_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Metadata::release__bytes() {
  // @@protoc_insertion_point(field_release:nnext.Metadata._bytes)
  if (_internal_has__bytes()) {
    clear_has_metafield();
    return metafield_._bytes_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Metadata::set_allocated__bytes(std::string* _bytes) {
  if (has_metafield()) {
    clear_metafield();
  }
  if (_bytes != nullptr) {
    set_has__bytes();
    metafield_._bytes_.UnsafeSetDefault(_bytes);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(_bytes);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:nnext.Metadata._bytes)
}

// string name = 16;
inline void Metadata::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Metadata::name() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.Metadata.name)
}
inline std::string* Metadata::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:nnext.Metadata.name)
  return _s;
}
inline const std::string& Metadata::_internal_name() const {
  return name_.Get();
}
inline void Metadata::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Metadata::release_name() {
  // @@protoc_insertion_point(field_release:nnext.Metadata.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Metadata::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.Metadata.name)
}

// .nnext.DataType type = 17;
inline void Metadata::clear_type() {
  type_ = 0;
}
inline ::nnext::DataType Metadata::_internal_type() const {
  return static_cast< ::nnext::DataType >(type_);
}
inline ::nnext::DataType Metadata::type() const {
  // @@protoc_insertion_point(field_get:nnext.Metadata.type)
  return _internal_type();
}
inline void Metadata::_internal_set_type(::nnext::DataType value) {
  
  type_ = value;
}
inline void Metadata::set_type(::nnext::DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:nnext.Metadata.type)
}

inline bool Metadata::has_metafield() const {
  return metafield_case() != METAFIELD_NOT_SET;
}
inline void Metadata::clear_has_metafield() {
  _oneof_case_[0] = METAFIELD_NOT_SET;
}
inline Metadata::MetafieldCase Metadata::metafield_case() const {
  return Metadata::MetafieldCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SchemaItem

// .nnext.DataType type = 1;
inline void SchemaItem::clear_type() {
  type_ = 0;
}
inline ::nnext::DataType SchemaItem::_internal_type() const {
  return static_cast< ::nnext::DataType >(type_);
}
inline ::nnext::DataType SchemaItem::type() const {
  // @@protoc_insertion_point(field_get:nnext.SchemaItem.type)
  return _internal_type();
}
inline void SchemaItem::_internal_set_type(::nnext::DataType value) {
  
  type_ = value;
}
inline void SchemaItem::set_type(::nnext::DataType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:nnext.SchemaItem.type)
}

// bool is_primary = 2;
inline void SchemaItem::clear_is_primary() {
  is_primary_ = false;
}
inline bool SchemaItem::_internal_is_primary() const {
  return is_primary_;
}
inline bool SchemaItem::is_primary() const {
  // @@protoc_insertion_point(field_get:nnext.SchemaItem.is_primary)
  return _internal_is_primary();
}
inline void SchemaItem::_internal_set_is_primary(bool value) {
  
  is_primary_ = value;
}
inline void SchemaItem::set_is_primary(bool value) {
  _internal_set_is_primary(value);
  // @@protoc_insertion_point(field_set:nnext.SchemaItem.is_primary)
}

// bool is_indexed = 3;
inline void SchemaItem::clear_is_indexed() {
  is_indexed_ = false;
}
inline bool SchemaItem::_internal_is_indexed() const {
  return is_indexed_;
}
inline bool SchemaItem::is_indexed() const {
  // @@protoc_insertion_point(field_get:nnext.SchemaItem.is_indexed)
  return _internal_is_indexed();
}
inline void SchemaItem::_internal_set_is_indexed(bool value) {
  
  is_indexed_ = value;
}
inline void SchemaItem::set_is_indexed(bool value) {
  _internal_set_is_indexed(value);
  // @@protoc_insertion_point(field_set:nnext.SchemaItem.is_indexed)
}

// string name = 4;
inline void SchemaItem::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& SchemaItem::name() const {
  // @@protoc_insertion_point(field_get:nnext.SchemaItem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SchemaItem::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.SchemaItem.name)
}
inline std::string* SchemaItem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:nnext.SchemaItem.name)
  return _s;
}
inline const std::string& SchemaItem::_internal_name() const {
  return name_.Get();
}
inline void SchemaItem::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SchemaItem::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SchemaItem::release_name() {
  // @@protoc_insertion_point(field_release:nnext.SchemaItem.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SchemaItem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.SchemaItem.name)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Schema

// map<string, .nnext.SchemaItem> schema_map = 1;
inline int Schema::_internal_schema_map_size() const {
  return schema_map_.size();
}
inline int Schema::schema_map_size() const {
  return _internal_schema_map_size();
}
inline void Schema::clear_schema_map() {
  schema_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::SchemaItem >&
Schema::_internal_schema_map() const {
  return schema_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::SchemaItem >&
Schema::schema_map() const {
  // @@protoc_insertion_point(field_map:nnext.Schema.schema_map)
  return _internal_schema_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::SchemaItem >*
Schema::_internal_mutable_schema_map() {
  return schema_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::SchemaItem >*
Schema::mutable_schema_map() {
  // @@protoc_insertion_point(field_mutable_map:nnext.Schema.schema_map)
  return _internal_mutable_schema_map();
}

// repeated .nnext.SchemaItem rptd__schema_item = 2;
inline int Schema::_internal_rptd__schema_item_size() const {
  return rptd__schema_item_.size();
}
inline int Schema::rptd__schema_item_size() const {
  return _internal_rptd__schema_item_size();
}
inline void Schema::clear_rptd__schema_item() {
  rptd__schema_item_.Clear();
}
inline ::nnext::SchemaItem* Schema::mutable_rptd__schema_item(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.Schema.rptd__schema_item)
  return rptd__schema_item_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::SchemaItem >*
Schema::mutable_rptd__schema_item() {
  // @@protoc_insertion_point(field_mutable_list:nnext.Schema.rptd__schema_item)
  return &rptd__schema_item_;
}
inline const ::nnext::SchemaItem& Schema::_internal_rptd__schema_item(int index) const {
  return rptd__schema_item_.Get(index);
}
inline const ::nnext::SchemaItem& Schema::rptd__schema_item(int index) const {
  // @@protoc_insertion_point(field_get:nnext.Schema.rptd__schema_item)
  return _internal_rptd__schema_item(index);
}
inline ::nnext::SchemaItem* Schema::_internal_add_rptd__schema_item() {
  return rptd__schema_item_.Add();
}
inline ::nnext::SchemaItem* Schema::add_rptd__schema_item() {
  ::nnext::SchemaItem* _add = _internal_add_rptd__schema_item();
  // @@protoc_insertion_point(field_add:nnext.Schema.rptd__schema_item)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::SchemaItem >&
Schema::rptd__schema_item() const {
  // @@protoc_insertion_point(field_list:nnext.Schema.rptd__schema_item)
  return rptd__schema_item_;
}

// -------------------------------------------------------------------

// Datum

// string id = 1;
inline void Datum::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Datum::id() const {
  // @@protoc_insertion_point(field_get:nnext.Datum.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Datum::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.Datum.id)
}
inline std::string* Datum::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:nnext.Datum.id)
  return _s;
}
inline const std::string& Datum::_internal_id() const {
  return id_.Get();
}
inline void Datum::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Datum::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Datum::release_id() {
  // @@protoc_insertion_point(field_release:nnext.Datum.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Datum::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.Datum.id)
}

// repeated float rptd__vector = 2;
inline int Datum::_internal_rptd__vector_size() const {
  return rptd__vector_.size();
}
inline int Datum::rptd__vector_size() const {
  return _internal_rptd__vector_size();
}
inline void Datum::clear_rptd__vector() {
  rptd__vector_.Clear();
}
inline float Datum::_internal_rptd__vector(int index) const {
  return rptd__vector_.Get(index);
}
inline float Datum::rptd__vector(int index) const {
  // @@protoc_insertion_point(field_get:nnext.Datum.rptd__vector)
  return _internal_rptd__vector(index);
}
inline void Datum::set_rptd__vector(int index, float value) {
  rptd__vector_.Set(index, value);
  // @@protoc_insertion_point(field_set:nnext.Datum.rptd__vector)
}
inline void Datum::_internal_add_rptd__vector(float value) {
  rptd__vector_.Add(value);
}
inline void Datum::add_rptd__vector(float value) {
  _internal_add_rptd__vector(value);
  // @@protoc_insertion_point(field_add:nnext.Datum.rptd__vector)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Datum::_internal_rptd__vector() const {
  return rptd__vector_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Datum::rptd__vector() const {
  // @@protoc_insertion_point(field_list:nnext.Datum.rptd__vector)
  return _internal_rptd__vector();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Datum::_internal_mutable_rptd__vector() {
  return &rptd__vector_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Datum::mutable_rptd__vector() {
  // @@protoc_insertion_point(field_mutable_list:nnext.Datum.rptd__vector)
  return _internal_mutable_rptd__vector();
}

// repeated .nnext.Metadata rptd__metadata = 3;
inline int Datum::_internal_rptd__metadata_size() const {
  return rptd__metadata_.size();
}
inline int Datum::rptd__metadata_size() const {
  return _internal_rptd__metadata_size();
}
inline void Datum::clear_rptd__metadata() {
  rptd__metadata_.Clear();
}
inline ::nnext::Metadata* Datum::mutable_rptd__metadata(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.Datum.rptd__metadata)
  return rptd__metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Metadata >*
Datum::mutable_rptd__metadata() {
  // @@protoc_insertion_point(field_mutable_list:nnext.Datum.rptd__metadata)
  return &rptd__metadata_;
}
inline const ::nnext::Metadata& Datum::_internal_rptd__metadata(int index) const {
  return rptd__metadata_.Get(index);
}
inline const ::nnext::Metadata& Datum::rptd__metadata(int index) const {
  // @@protoc_insertion_point(field_get:nnext.Datum.rptd__metadata)
  return _internal_rptd__metadata(index);
}
inline ::nnext::Metadata* Datum::_internal_add_rptd__metadata() {
  return rptd__metadata_.Add();
}
inline ::nnext::Metadata* Datum::add_rptd__metadata() {
  ::nnext::Metadata* _add = _internal_add_rptd__metadata();
  // @@protoc_insertion_point(field_add:nnext.Datum.rptd__metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Metadata >&
Datum::rptd__metadata() const {
  // @@protoc_insertion_point(field_list:nnext.Datum.rptd__metadata)
  return rptd__metadata_;
}

// -------------------------------------------------------------------

// DataList

// repeated float data = 1;
inline int DataList::_internal_data_size() const {
  return data_.size();
}
inline int DataList::data_size() const {
  return _internal_data_size();
}
inline void DataList::clear_data() {
  data_.Clear();
}
inline float DataList::_internal_data(int index) const {
  return data_.Get(index);
}
inline float DataList::data(int index) const {
  // @@protoc_insertion_point(field_get:nnext.DataList.data)
  return _internal_data(index);
}
inline void DataList::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:nnext.DataList.data)
}
inline void DataList::_internal_add_data(float value) {
  data_.Add(value);
}
inline void DataList::add_data(float value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:nnext.DataList.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
DataList::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
DataList::data() const {
  // @@protoc_insertion_point(field_list:nnext.DataList.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
DataList::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
DataList::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:nnext.DataList.data)
  return _internal_mutable_data();
}

// -------------------------------------------------------------------

// Vector

// repeated float rptd__element = 1;
inline int Vector::_internal_rptd__element_size() const {
  return rptd__element_.size();
}
inline int Vector::rptd__element_size() const {
  return _internal_rptd__element_size();
}
inline void Vector::clear_rptd__element() {
  rptd__element_.Clear();
}
inline float Vector::_internal_rptd__element(int index) const {
  return rptd__element_.Get(index);
}
inline float Vector::rptd__element(int index) const {
  // @@protoc_insertion_point(field_get:nnext.Vector.rptd__element)
  return _internal_rptd__element(index);
}
inline void Vector::set_rptd__element(int index, float value) {
  rptd__element_.Set(index, value);
  // @@protoc_insertion_point(field_set:nnext.Vector.rptd__element)
}
inline void Vector::_internal_add_rptd__element(float value) {
  rptd__element_.Add(value);
}
inline void Vector::add_rptd__element(float value) {
  _internal_add_rptd__element(value);
  // @@protoc_insertion_point(field_add:nnext.Vector.rptd__element)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Vector::_internal_rptd__element() const {
  return rptd__element_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Vector::rptd__element() const {
  // @@protoc_insertion_point(field_list:nnext.Vector.rptd__element)
  return _internal_rptd__element();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Vector::_internal_mutable_rptd__element() {
  return &rptd__element_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Vector::mutable_rptd__element() {
  // @@protoc_insertion_point(field_mutable_list:nnext.Vector.rptd__element)
  return _internal_mutable_rptd__element();
}

// -------------------------------------------------------------------

// VectorList

// repeated .nnext.Vector rptd__vector = 1;
inline int VectorList::_internal_rptd__vector_size() const {
  return rptd__vector_.size();
}
inline int VectorList::rptd__vector_size() const {
  return _internal_rptd__vector_size();
}
inline void VectorList::clear_rptd__vector() {
  rptd__vector_.Clear();
}
inline ::nnext::Vector* VectorList::mutable_rptd__vector(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorList.rptd__vector)
  return rptd__vector_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Vector >*
VectorList::mutable_rptd__vector() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorList.rptd__vector)
  return &rptd__vector_;
}
inline const ::nnext::Vector& VectorList::_internal_rptd__vector(int index) const {
  return rptd__vector_.Get(index);
}
inline const ::nnext::Vector& VectorList::rptd__vector(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorList.rptd__vector)
  return _internal_rptd__vector(index);
}
inline ::nnext::Vector* VectorList::_internal_add_rptd__vector() {
  return rptd__vector_.Add();
}
inline ::nnext::Vector* VectorList::add_rptd__vector() {
  ::nnext::Vector* _add = _internal_add_rptd__vector();
  // @@protoc_insertion_point(field_add:nnext.VectorList.rptd__vector)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Vector >&
VectorList::rptd__vector() const {
  // @@protoc_insertion_point(field_list:nnext.VectorList.rptd__vector)
  return rptd__vector_;
}

// -------------------------------------------------------------------

// Index

// string name = 1;
inline void Index::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Index::name() const {
  // @@protoc_insertion_point(field_get:nnext.Index.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Index::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.Index.name)
}
inline std::string* Index::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:nnext.Index.name)
  return _s;
}
inline const std::string& Index::_internal_name() const {
  return name_.Get();
}
inline void Index::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Index::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Index::release_name() {
  // @@protoc_insertion_point(field_release:nnext.Index.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Index::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.Index.name)
}

// uint32 dims = 2;
inline void Index::clear_dims() {
  dims_ = 0u;
}
inline uint32_t Index::_internal_dims() const {
  return dims_;
}
inline uint32_t Index::dims() const {
  // @@protoc_insertion_point(field_get:nnext.Index.dims)
  return _internal_dims();
}
inline void Index::_internal_set_dims(uint32_t value) {
  
  dims_ = value;
}
inline void Index::set_dims(uint32_t value) {
  _internal_set_dims(value);
  // @@protoc_insertion_point(field_set:nnext.Index.dims)
}

// optional .nnext.IndexType index_type = 3;
inline bool Index::_internal_has_index_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Index::has_index_type() const {
  return _internal_has_index_type();
}
inline void Index::clear_index_type() {
  index_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::nnext::IndexType Index::_internal_index_type() const {
  return static_cast< ::nnext::IndexType >(index_type_);
}
inline ::nnext::IndexType Index::index_type() const {
  // @@protoc_insertion_point(field_get:nnext.Index.index_type)
  return _internal_index_type();
}
inline void Index::_internal_set_index_type(::nnext::IndexType value) {
  _has_bits_[0] |= 0x00000001u;
  index_type_ = value;
}
inline void Index::set_index_type(::nnext::IndexType value) {
  _internal_set_index_type(value);
  // @@protoc_insertion_point(field_set:nnext.Index.index_type)
}

// optional .nnext.MetricType metric = 4;
inline bool Index::_internal_has_metric() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Index::has_metric() const {
  return _internal_has_metric();
}
inline void Index::clear_metric() {
  metric_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::nnext::MetricType Index::_internal_metric() const {
  return static_cast< ::nnext::MetricType >(metric_);
}
inline ::nnext::MetricType Index::metric() const {
  // @@protoc_insertion_point(field_get:nnext.Index.metric)
  return _internal_metric();
}
inline void Index::_internal_set_metric(::nnext::MetricType value) {
  _has_bits_[0] |= 0x00000002u;
  metric_ = value;
}
inline void Index::set_metric(::nnext::MetricType value) {
  _internal_set_metric(value);
  // @@protoc_insertion_point(field_set:nnext.Index.metric)
}

// bool is_trained = 5;
inline void Index::clear_is_trained() {
  is_trained_ = false;
}
inline bool Index::_internal_is_trained() const {
  return is_trained_;
}
inline bool Index::is_trained() const {
  // @@protoc_insertion_point(field_get:nnext.Index.is_trained)
  return _internal_is_trained();
}
inline void Index::_internal_set_is_trained(bool value) {
  
  is_trained_ = value;
}
inline void Index::set_is_trained(bool value) {
  _internal_set_is_trained(value);
  // @@protoc_insertion_point(field_set:nnext.Index.is_trained)
}

// uint64 ntotal = 6;
inline void Index::clear_ntotal() {
  ntotal_ = uint64_t{0u};
}
inline uint64_t Index::_internal_ntotal() const {
  return ntotal_;
}
inline uint64_t Index::ntotal() const {
  // @@protoc_insertion_point(field_get:nnext.Index.ntotal)
  return _internal_ntotal();
}
inline void Index::_internal_set_ntotal(uint64_t value) {
  
  ntotal_ = value;
}
inline void Index::set_ntotal(uint64_t value) {
  _internal_set_ntotal(value);
  // @@protoc_insertion_point(field_set:nnext.Index.ntotal)
}

// .nnext.Schema schema = 7;
inline bool Index::_internal_has_schema() const {
  return this != internal_default_instance() && schema_ != nullptr;
}
inline bool Index::has_schema() const {
  return _internal_has_schema();
}
inline void Index::clear_schema() {
  if (GetArenaForAllocation() == nullptr && schema_ != nullptr) {
    delete schema_;
  }
  schema_ = nullptr;
}
inline const ::nnext::Schema& Index::_internal_schema() const {
  const ::nnext::Schema* p = schema_;
  return p != nullptr ? *p : reinterpret_cast<const ::nnext::Schema&>(
      ::nnext::_Schema_default_instance_);
}
inline const ::nnext::Schema& Index::schema() const {
  // @@protoc_insertion_point(field_get:nnext.Index.schema)
  return _internal_schema();
}
inline void Index::unsafe_arena_set_allocated_schema(
    ::nnext::Schema* schema) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(schema_);
  }
  schema_ = schema;
  if (schema) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nnext.Index.schema)
}
inline ::nnext::Schema* Index::release_schema() {
  
  ::nnext::Schema* temp = schema_;
  schema_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nnext::Schema* Index::unsafe_arena_release_schema() {
  // @@protoc_insertion_point(field_release:nnext.Index.schema)
  
  ::nnext::Schema* temp = schema_;
  schema_ = nullptr;
  return temp;
}
inline ::nnext::Schema* Index::_internal_mutable_schema() {
  
  if (schema_ == nullptr) {
    auto* p = CreateMaybeMessage<::nnext::Schema>(GetArenaForAllocation());
    schema_ = p;
  }
  return schema_;
}
inline ::nnext::Schema* Index::mutable_schema() {
  ::nnext::Schema* _msg = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:nnext.Index.schema)
  return _msg;
}
inline void Index::set_allocated_schema(::nnext::Schema* schema) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete schema_;
  }
  if (schema) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::nnext::Schema>::GetOwningArena(schema);
    if (message_arena != submessage_arena) {
      schema = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, schema, submessage_arena);
    }
    
  } else {
    
  }
  schema_ = schema;
  // @@protoc_insertion_point(field_set_allocated:nnext.Index.schema)
}

// -------------------------------------------------------------------

// IndexList

// repeated .nnext.Index indices = 1;
inline int IndexList::_internal_indices_size() const {
  return indices_.size();
}
inline int IndexList::indices_size() const {
  return _internal_indices_size();
}
inline void IndexList::clear_indices() {
  indices_.Clear();
}
inline ::nnext::Index* IndexList::mutable_indices(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.IndexList.indices)
  return indices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Index >*
IndexList::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:nnext.IndexList.indices)
  return &indices_;
}
inline const ::nnext::Index& IndexList::_internal_indices(int index) const {
  return indices_.Get(index);
}
inline const ::nnext::Index& IndexList::indices(int index) const {
  // @@protoc_insertion_point(field_get:nnext.IndexList.indices)
  return _internal_indices(index);
}
inline ::nnext::Index* IndexList::_internal_add_indices() {
  return indices_.Add();
}
inline ::nnext::Index* IndexList::add_indices() {
  ::nnext::Index* _add = _internal_add_indices();
  // @@protoc_insertion_point(field_add:nnext.IndexList.indices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Index >&
IndexList::indices() const {
  // @@protoc_insertion_point(field_list:nnext.IndexList.indices)
  return indices_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// IndexMap

// map<string, .nnext.Index> indices = 1;
inline int IndexMap::_internal_indices_size() const {
  return indices_.size();
}
inline int IndexMap::indices_size() const {
  return _internal_indices_size();
}
inline void IndexMap::clear_indices() {
  indices_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::Index >&
IndexMap::_internal_indices() const {
  return indices_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::Index >&
IndexMap::indices() const {
  // @@protoc_insertion_point(field_map:nnext.IndexMap.indices)
  return _internal_indices();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::Index >*
IndexMap::_internal_mutable_indices() {
  return indices_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::nnext::Index >*
IndexMap::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_map:nnext.IndexMap.indices)
  return _internal_mutable_indices();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// IdMap

// map<string, int64> idx = 1;
inline int IdMap::_internal_idx_size() const {
  return idx_.size();
}
inline int IdMap::idx_size() const {
  return _internal_idx_size();
}
inline void IdMap::clear_idx() {
  idx_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
IdMap::_internal_idx() const {
  return idx_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
IdMap::idx() const {
  // @@protoc_insertion_point(field_map:nnext.IdMap.idx)
  return _internal_idx();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
IdMap::_internal_mutable_idx() {
  return idx_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
IdMap::mutable_idx() {
  // @@protoc_insertion_point(field_mutable_map:nnext.IdMap.idx)
  return _internal_mutable_idx();
}

// map<int64, string> inv = 2;
inline int IdMap::_internal_inv_size() const {
  return inv_.size();
}
inline int IdMap::inv_size() const {
  return _internal_inv_size();
}
inline void IdMap::clear_inv() {
  inv_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >&
IdMap::_internal_inv() const {
  return inv_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >&
IdMap::inv() const {
  // @@protoc_insertion_point(field_map:nnext.IdMap.inv)
  return _internal_inv();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >*
IdMap::_internal_mutable_inv() {
  return inv_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, std::string >*
IdMap::mutable_inv() {
  // @@protoc_insertion_point(field_mutable_map:nnext.IdMap.inv)
  return _internal_mutable_inv();
}

// -------------------------------------------------------------------

// CreateIndexRequest

// string name = 1;
inline void CreateIndexRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CreateIndexRequest::name() const {
  // @@protoc_insertion_point(field_get:nnext.CreateIndexRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIndexRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.CreateIndexRequest.name)
}
inline std::string* CreateIndexRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:nnext.CreateIndexRequest.name)
  return _s;
}
inline const std::string& CreateIndexRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateIndexRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::release_name() {
  // @@protoc_insertion_point(field_release:nnext.CreateIndexRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateIndexRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.CreateIndexRequest.name)
}

// int32 dims = 2;
inline void CreateIndexRequest::clear_dims() {
  dims_ = 0;
}
inline int32_t CreateIndexRequest::_internal_dims() const {
  return dims_;
}
inline int32_t CreateIndexRequest::dims() const {
  // @@protoc_insertion_point(field_get:nnext.CreateIndexRequest.dims)
  return _internal_dims();
}
inline void CreateIndexRequest::_internal_set_dims(int32_t value) {
  
  dims_ = value;
}
inline void CreateIndexRequest::set_dims(int32_t value) {
  _internal_set_dims(value);
  // @@protoc_insertion_point(field_set:nnext.CreateIndexRequest.dims)
}

// .nnext.IndexType index_type = 3;
inline void CreateIndexRequest::clear_index_type() {
  index_type_ = 0;
}
inline ::nnext::IndexType CreateIndexRequest::_internal_index_type() const {
  return static_cast< ::nnext::IndexType >(index_type_);
}
inline ::nnext::IndexType CreateIndexRequest::index_type() const {
  // @@protoc_insertion_point(field_get:nnext.CreateIndexRequest.index_type)
  return _internal_index_type();
}
inline void CreateIndexRequest::_internal_set_index_type(::nnext::IndexType value) {
  
  index_type_ = value;
}
inline void CreateIndexRequest::set_index_type(::nnext::IndexType value) {
  _internal_set_index_type(value);
  // @@protoc_insertion_point(field_set:nnext.CreateIndexRequest.index_type)
}

// .nnext.MetricType metric_type = 4;
inline void CreateIndexRequest::clear_metric_type() {
  metric_type_ = 0;
}
inline ::nnext::MetricType CreateIndexRequest::_internal_metric_type() const {
  return static_cast< ::nnext::MetricType >(metric_type_);
}
inline ::nnext::MetricType CreateIndexRequest::metric_type() const {
  // @@protoc_insertion_point(field_get:nnext.CreateIndexRequest.metric_type)
  return _internal_metric_type();
}
inline void CreateIndexRequest::_internal_set_metric_type(::nnext::MetricType value) {
  
  metric_type_ = value;
}
inline void CreateIndexRequest::set_metric_type(::nnext::MetricType value) {
  _internal_set_metric_type(value);
  // @@protoc_insertion_point(field_set:nnext.CreateIndexRequest.metric_type)
}

// string schema = 5;
inline void CreateIndexRequest::clear_schema() {
  schema_.ClearToEmpty();
}
inline const std::string& CreateIndexRequest::schema() const {
  // @@protoc_insertion_point(field_get:nnext.CreateIndexRequest.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateIndexRequest::set_schema(ArgT0&& arg0, ArgT... args) {
 
 schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.CreateIndexRequest.schema)
}
inline std::string* CreateIndexRequest::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:nnext.CreateIndexRequest.schema)
  return _s;
}
inline const std::string& CreateIndexRequest::_internal_schema() const {
  return schema_.Get();
}
inline void CreateIndexRequest::_internal_set_schema(const std::string& value) {
  
  schema_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::_internal_mutable_schema() {
  
  return schema_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreateIndexRequest::release_schema() {
  // @@protoc_insertion_point(field_release:nnext.CreateIndexRequest.schema)
  return schema_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreateIndexRequest::set_allocated_schema(std::string* schema) {
  if (schema != nullptr) {
    
  } else {
    
  }
  schema_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schema_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schema_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.CreateIndexRequest.schema)
}

// -------------------------------------------------------------------

// CreateIndexResponse

// .nnext.Index index = 1;
inline bool CreateIndexResponse::_internal_has_index() const {
  return this != internal_default_instance() && index_ != nullptr;
}
inline bool CreateIndexResponse::has_index() const {
  return _internal_has_index();
}
inline void CreateIndexResponse::clear_index() {
  if (GetArenaForAllocation() == nullptr && index_ != nullptr) {
    delete index_;
  }
  index_ = nullptr;
}
inline const ::nnext::Index& CreateIndexResponse::_internal_index() const {
  const ::nnext::Index* p = index_;
  return p != nullptr ? *p : reinterpret_cast<const ::nnext::Index&>(
      ::nnext::_Index_default_instance_);
}
inline const ::nnext::Index& CreateIndexResponse::index() const {
  // @@protoc_insertion_point(field_get:nnext.CreateIndexResponse.index)
  return _internal_index();
}
inline void CreateIndexResponse::unsafe_arena_set_allocated_index(
    ::nnext::Index* index) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_);
  }
  index_ = index;
  if (index) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nnext.CreateIndexResponse.index)
}
inline ::nnext::Index* CreateIndexResponse::release_index() {
  
  ::nnext::Index* temp = index_;
  index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nnext::Index* CreateIndexResponse::unsafe_arena_release_index() {
  // @@protoc_insertion_point(field_release:nnext.CreateIndexResponse.index)
  
  ::nnext::Index* temp = index_;
  index_ = nullptr;
  return temp;
}
inline ::nnext::Index* CreateIndexResponse::_internal_mutable_index() {
  
  if (index_ == nullptr) {
    auto* p = CreateMaybeMessage<::nnext::Index>(GetArenaForAllocation());
    index_ = p;
  }
  return index_;
}
inline ::nnext::Index* CreateIndexResponse::mutable_index() {
  ::nnext::Index* _msg = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:nnext.CreateIndexResponse.index)
  return _msg;
}
inline void CreateIndexResponse::set_allocated_index(::nnext::Index* index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete index_;
  }
  if (index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::nnext::Index>::GetOwningArena(index);
    if (message_arena != submessage_arena) {
      index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index, submessage_arena);
    }
    
  } else {
    
  }
  index_ = index;
  // @@protoc_insertion_point(field_set_allocated:nnext.CreateIndexResponse.index)
}

// -------------------------------------------------------------------

// ListIndicesRequest

// string pattern = 1;
inline void ListIndicesRequest::clear_pattern() {
  pattern_.ClearToEmpty();
}
inline const std::string& ListIndicesRequest::pattern() const {
  // @@protoc_insertion_point(field_get:nnext.ListIndicesRequest.pattern)
  return _internal_pattern();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListIndicesRequest::set_pattern(ArgT0&& arg0, ArgT... args) {
 
 pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.ListIndicesRequest.pattern)
}
inline std::string* ListIndicesRequest::mutable_pattern() {
  std::string* _s = _internal_mutable_pattern();
  // @@protoc_insertion_point(field_mutable:nnext.ListIndicesRequest.pattern)
  return _s;
}
inline const std::string& ListIndicesRequest::_internal_pattern() const {
  return pattern_.Get();
}
inline void ListIndicesRequest::_internal_set_pattern(const std::string& value) {
  
  pattern_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ListIndicesRequest::_internal_mutable_pattern() {
  
  return pattern_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ListIndicesRequest::release_pattern() {
  // @@protoc_insertion_point(field_release:nnext.ListIndicesRequest.pattern)
  return pattern_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ListIndicesRequest::set_allocated_pattern(std::string* pattern) {
  if (pattern != nullptr) {
    
  } else {
    
  }
  pattern_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pattern,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pattern_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pattern_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.ListIndicesRequest.pattern)
}

// uint32 offset = 2;
inline void ListIndicesRequest::clear_offset() {
  offset_ = 0u;
}
inline uint32_t ListIndicesRequest::_internal_offset() const {
  return offset_;
}
inline uint32_t ListIndicesRequest::offset() const {
  // @@protoc_insertion_point(field_get:nnext.ListIndicesRequest.offset)
  return _internal_offset();
}
inline void ListIndicesRequest::_internal_set_offset(uint32_t value) {
  
  offset_ = value;
}
inline void ListIndicesRequest::set_offset(uint32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:nnext.ListIndicesRequest.offset)
}

// uint32 size = 3;
inline void ListIndicesRequest::clear_size() {
  size_ = 0u;
}
inline uint32_t ListIndicesRequest::_internal_size() const {
  return size_;
}
inline uint32_t ListIndicesRequest::size() const {
  // @@protoc_insertion_point(field_get:nnext.ListIndicesRequest.size)
  return _internal_size();
}
inline void ListIndicesRequest::_internal_set_size(uint32_t value) {
  
  size_ = value;
}
inline void ListIndicesRequest::set_size(uint32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:nnext.ListIndicesRequest.size)
}

// uint32 dims = 4;
inline void ListIndicesRequest::clear_dims() {
  dims_ = 0u;
}
inline uint32_t ListIndicesRequest::_internal_dims() const {
  return dims_;
}
inline uint32_t ListIndicesRequest::dims() const {
  // @@protoc_insertion_point(field_get:nnext.ListIndicesRequest.dims)
  return _internal_dims();
}
inline void ListIndicesRequest::_internal_set_dims(uint32_t value) {
  
  dims_ = value;
}
inline void ListIndicesRequest::set_dims(uint32_t value) {
  _internal_set_dims(value);
  // @@protoc_insertion_point(field_set:nnext.ListIndicesRequest.dims)
}

// -------------------------------------------------------------------

// ListIndicesResponse

// repeated .nnext.Index indices = 1;
inline int ListIndicesResponse::_internal_indices_size() const {
  return indices_.size();
}
inline int ListIndicesResponse::indices_size() const {
  return _internal_indices_size();
}
inline void ListIndicesResponse::clear_indices() {
  indices_.Clear();
}
inline ::nnext::Index* ListIndicesResponse::mutable_indices(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.ListIndicesResponse.indices)
  return indices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Index >*
ListIndicesResponse::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:nnext.ListIndicesResponse.indices)
  return &indices_;
}
inline const ::nnext::Index& ListIndicesResponse::_internal_indices(int index) const {
  return indices_.Get(index);
}
inline const ::nnext::Index& ListIndicesResponse::indices(int index) const {
  // @@protoc_insertion_point(field_get:nnext.ListIndicesResponse.indices)
  return _internal_indices(index);
}
inline ::nnext::Index* ListIndicesResponse::_internal_add_indices() {
  return indices_.Add();
}
inline ::nnext::Index* ListIndicesResponse::add_indices() {
  ::nnext::Index* _add = _internal_add_indices();
  // @@protoc_insertion_point(field_add:nnext.ListIndicesResponse.indices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Index >&
ListIndicesResponse::indices() const {
  // @@protoc_insertion_point(field_list:nnext.ListIndicesResponse.indices)
  return indices_;
}

// uint32 total = 2;
inline void ListIndicesResponse::clear_total() {
  total_ = 0u;
}
inline uint32_t ListIndicesResponse::_internal_total() const {
  return total_;
}
inline uint32_t ListIndicesResponse::total() const {
  // @@protoc_insertion_point(field_get:nnext.ListIndicesResponse.total)
  return _internal_total();
}
inline void ListIndicesResponse::_internal_set_total(uint32_t value) {
  
  total_ = value;
}
inline void ListIndicesResponse::set_total(uint32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:nnext.ListIndicesResponse.total)
}

// -------------------------------------------------------------------

// DropIndexRequest

// string name = 1;
inline void DropIndexRequest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DropIndexRequest::name() const {
  // @@protoc_insertion_point(field_get:nnext.DropIndexRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DropIndexRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.DropIndexRequest.name)
}
inline std::string* DropIndexRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:nnext.DropIndexRequest.name)
  return _s;
}
inline const std::string& DropIndexRequest::_internal_name() const {
  return name_.Get();
}
inline void DropIndexRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DropIndexRequest::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DropIndexRequest::release_name() {
  // @@protoc_insertion_point(field_release:nnext.DropIndexRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DropIndexRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.DropIndexRequest.name)
}

// -------------------------------------------------------------------

// DropIndexResponse

// .nnext.Index index = 1;
inline bool DropIndexResponse::_internal_has_index() const {
  return this != internal_default_instance() && index_ != nullptr;
}
inline bool DropIndexResponse::has_index() const {
  return _internal_has_index();
}
inline void DropIndexResponse::clear_index() {
  if (GetArenaForAllocation() == nullptr && index_ != nullptr) {
    delete index_;
  }
  index_ = nullptr;
}
inline const ::nnext::Index& DropIndexResponse::_internal_index() const {
  const ::nnext::Index* p = index_;
  return p != nullptr ? *p : reinterpret_cast<const ::nnext::Index&>(
      ::nnext::_Index_default_instance_);
}
inline const ::nnext::Index& DropIndexResponse::index() const {
  // @@protoc_insertion_point(field_get:nnext.DropIndexResponse.index)
  return _internal_index();
}
inline void DropIndexResponse::unsafe_arena_set_allocated_index(
    ::nnext::Index* index) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(index_);
  }
  index_ = index;
  if (index) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:nnext.DropIndexResponse.index)
}
inline ::nnext::Index* DropIndexResponse::release_index() {
  
  ::nnext::Index* temp = index_;
  index_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::nnext::Index* DropIndexResponse::unsafe_arena_release_index() {
  // @@protoc_insertion_point(field_release:nnext.DropIndexResponse.index)
  
  ::nnext::Index* temp = index_;
  index_ = nullptr;
  return temp;
}
inline ::nnext::Index* DropIndexResponse::_internal_mutable_index() {
  
  if (index_ == nullptr) {
    auto* p = CreateMaybeMessage<::nnext::Index>(GetArenaForAllocation());
    index_ = p;
  }
  return index_;
}
inline ::nnext::Index* DropIndexResponse::mutable_index() {
  ::nnext::Index* _msg = _internal_mutable_index();
  // @@protoc_insertion_point(field_mutable:nnext.DropIndexResponse.index)
  return _msg;
}
inline void DropIndexResponse::set_allocated_index(::nnext::Index* index) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete index_;
  }
  if (index) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::nnext::Index>::GetOwningArena(index);
    if (message_arena != submessage_arena) {
      index = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, index, submessage_arena);
    }
    
  } else {
    
  }
  index_ = index;
  // @@protoc_insertion_point(field_set_allocated:nnext.DropIndexResponse.index)
}

// -------------------------------------------------------------------

// VectorAddRequest

// string index_name = 1;
inline void VectorAddRequest::clear_index_name() {
  index_name_.ClearToEmpty();
}
inline const std::string& VectorAddRequest::index_name() const {
  // @@protoc_insertion_point(field_get:nnext.VectorAddRequest.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorAddRequest::set_index_name(ArgT0&& arg0, ArgT... args) {
 
 index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.VectorAddRequest.index_name)
}
inline std::string* VectorAddRequest::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:nnext.VectorAddRequest.index_name)
  return _s;
}
inline const std::string& VectorAddRequest::_internal_index_name() const {
  return index_name_.Get();
}
inline void VectorAddRequest::_internal_set_index_name(const std::string& value) {
  
  index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VectorAddRequest::_internal_mutable_index_name() {
  
  return index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VectorAddRequest::release_index_name() {
  // @@protoc_insertion_point(field_release:nnext.VectorAddRequest.index_name)
  return index_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VectorAddRequest::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    
  } else {
    
  }
  index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (index_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    index_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.VectorAddRequest.index_name)
}

// string header_cols = 2;
inline void VectorAddRequest::clear_header_cols() {
  header_cols_.ClearToEmpty();
}
inline const std::string& VectorAddRequest::header_cols() const {
  // @@protoc_insertion_point(field_get:nnext.VectorAddRequest.header_cols)
  return _internal_header_cols();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorAddRequest::set_header_cols(ArgT0&& arg0, ArgT... args) {
 
 header_cols_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.VectorAddRequest.header_cols)
}
inline std::string* VectorAddRequest::mutable_header_cols() {
  std::string* _s = _internal_mutable_header_cols();
  // @@protoc_insertion_point(field_mutable:nnext.VectorAddRequest.header_cols)
  return _s;
}
inline const std::string& VectorAddRequest::_internal_header_cols() const {
  return header_cols_.Get();
}
inline void VectorAddRequest::_internal_set_header_cols(const std::string& value) {
  
  header_cols_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VectorAddRequest::_internal_mutable_header_cols() {
  
  return header_cols_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VectorAddRequest::release_header_cols() {
  // @@protoc_insertion_point(field_release:nnext.VectorAddRequest.header_cols)
  return header_cols_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VectorAddRequest::set_allocated_header_cols(std::string* header_cols) {
  if (header_cols != nullptr) {
    
  } else {
    
  }
  header_cols_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), header_cols,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (header_cols_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    header_cols_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.VectorAddRequest.header_cols)
}

// string header_types = 3;
inline void VectorAddRequest::clear_header_types() {
  header_types_.ClearToEmpty();
}
inline const std::string& VectorAddRequest::header_types() const {
  // @@protoc_insertion_point(field_get:nnext.VectorAddRequest.header_types)
  return _internal_header_types();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorAddRequest::set_header_types(ArgT0&& arg0, ArgT... args) {
 
 header_types_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.VectorAddRequest.header_types)
}
inline std::string* VectorAddRequest::mutable_header_types() {
  std::string* _s = _internal_mutable_header_types();
  // @@protoc_insertion_point(field_mutable:nnext.VectorAddRequest.header_types)
  return _s;
}
inline const std::string& VectorAddRequest::_internal_header_types() const {
  return header_types_.Get();
}
inline void VectorAddRequest::_internal_set_header_types(const std::string& value) {
  
  header_types_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VectorAddRequest::_internal_mutable_header_types() {
  
  return header_types_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VectorAddRequest::release_header_types() {
  // @@protoc_insertion_point(field_release:nnext.VectorAddRequest.header_types)
  return header_types_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VectorAddRequest::set_allocated_header_types(std::string* header_types) {
  if (header_types != nullptr) {
    
  } else {
    
  }
  header_types_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), header_types,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (header_types_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    header_types_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.VectorAddRequest.header_types)
}

// repeated .nnext.Datum data = 4;
inline int VectorAddRequest::_internal_data_size() const {
  return data_.size();
}
inline int VectorAddRequest::data_size() const {
  return _internal_data_size();
}
inline void VectorAddRequest::clear_data() {
  data_.Clear();
}
inline ::nnext::Datum* VectorAddRequest::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorAddRequest.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
VectorAddRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorAddRequest.data)
  return &data_;
}
inline const ::nnext::Datum& VectorAddRequest::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::nnext::Datum& VectorAddRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorAddRequest.data)
  return _internal_data(index);
}
inline ::nnext::Datum* VectorAddRequest::_internal_add_data() {
  return data_.Add();
}
inline ::nnext::Datum* VectorAddRequest::add_data() {
  ::nnext::Datum* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:nnext.VectorAddRequest.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
VectorAddRequest::data() const {
  // @@protoc_insertion_point(field_list:nnext.VectorAddRequest.data)
  return data_;
}

// -------------------------------------------------------------------

// VectorAddResponse

// repeated .nnext.Datum data = 1;
inline int VectorAddResponse::_internal_data_size() const {
  return data_.size();
}
inline int VectorAddResponse::data_size() const {
  return _internal_data_size();
}
inline void VectorAddResponse::clear_data() {
  data_.Clear();
}
inline ::nnext::Datum* VectorAddResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorAddResponse.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
VectorAddResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorAddResponse.data)
  return &data_;
}
inline const ::nnext::Datum& VectorAddResponse::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::nnext::Datum& VectorAddResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorAddResponse.data)
  return _internal_data(index);
}
inline ::nnext::Datum* VectorAddResponse::_internal_add_data() {
  return data_.Add();
}
inline ::nnext::Datum* VectorAddResponse::add_data() {
  ::nnext::Datum* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:nnext.VectorAddResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
VectorAddResponse::data() const {
  // @@protoc_insertion_point(field_list:nnext.VectorAddResponse.data)
  return data_;
}

// uint64 total = 2;
inline void VectorAddResponse::clear_total() {
  total_ = uint64_t{0u};
}
inline uint64_t VectorAddResponse::_internal_total() const {
  return total_;
}
inline uint64_t VectorAddResponse::total() const {
  // @@protoc_insertion_point(field_get:nnext.VectorAddResponse.total)
  return _internal_total();
}
inline void VectorAddResponse::_internal_set_total(uint64_t value) {
  
  total_ = value;
}
inline void VectorAddResponse::set_total(uint64_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:nnext.VectorAddResponse.total)
}

// -------------------------------------------------------------------

// VectorSearchRequest

// string index_name = 1;
inline void VectorSearchRequest::clear_index_name() {
  index_name_.ClearToEmpty();
}
inline const std::string& VectorSearchRequest::index_name() const {
  // @@protoc_insertion_point(field_get:nnext.VectorSearchRequest.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorSearchRequest::set_index_name(ArgT0&& arg0, ArgT... args) {
 
 index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.VectorSearchRequest.index_name)
}
inline std::string* VectorSearchRequest::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:nnext.VectorSearchRequest.index_name)
  return _s;
}
inline const std::string& VectorSearchRequest::_internal_index_name() const {
  return index_name_.Get();
}
inline void VectorSearchRequest::_internal_set_index_name(const std::string& value) {
  
  index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VectorSearchRequest::_internal_mutable_index_name() {
  
  return index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VectorSearchRequest::release_index_name() {
  // @@protoc_insertion_point(field_release:nnext.VectorSearchRequest.index_name)
  return index_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VectorSearchRequest::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    
  } else {
    
  }
  index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (index_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    index_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.VectorSearchRequest.index_name)
}

// repeated .nnext.Vector rptd_query_vector = 2;
inline int VectorSearchRequest::_internal_rptd_query_vector_size() const {
  return rptd_query_vector_.size();
}
inline int VectorSearchRequest::rptd_query_vector_size() const {
  return _internal_rptd_query_vector_size();
}
inline void VectorSearchRequest::clear_rptd_query_vector() {
  rptd_query_vector_.Clear();
}
inline ::nnext::Vector* VectorSearchRequest::mutable_rptd_query_vector(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorSearchRequest.rptd_query_vector)
  return rptd_query_vector_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Vector >*
VectorSearchRequest::mutable_rptd_query_vector() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorSearchRequest.rptd_query_vector)
  return &rptd_query_vector_;
}
inline const ::nnext::Vector& VectorSearchRequest::_internal_rptd_query_vector(int index) const {
  return rptd_query_vector_.Get(index);
}
inline const ::nnext::Vector& VectorSearchRequest::rptd_query_vector(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorSearchRequest.rptd_query_vector)
  return _internal_rptd_query_vector(index);
}
inline ::nnext::Vector* VectorSearchRequest::_internal_add_rptd_query_vector() {
  return rptd_query_vector_.Add();
}
inline ::nnext::Vector* VectorSearchRequest::add_rptd_query_vector() {
  ::nnext::Vector* _add = _internal_add_rptd_query_vector();
  // @@protoc_insertion_point(field_add:nnext.VectorSearchRequest.rptd_query_vector)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Vector >&
VectorSearchRequest::rptd_query_vector() const {
  // @@protoc_insertion_point(field_list:nnext.VectorSearchRequest.rptd_query_vector)
  return rptd_query_vector_;
}

// uint32 k = 3;
inline void VectorSearchRequest::clear_k() {
  k_ = 0u;
}
inline uint32_t VectorSearchRequest::_internal_k() const {
  return k_;
}
inline uint32_t VectorSearchRequest::k() const {
  // @@protoc_insertion_point(field_get:nnext.VectorSearchRequest.k)
  return _internal_k();
}
inline void VectorSearchRequest::_internal_set_k(uint32_t value) {
  
  k_ = value;
}
inline void VectorSearchRequest::set_k(uint32_t value) {
  _internal_set_k(value);
  // @@protoc_insertion_point(field_set:nnext.VectorSearchRequest.k)
}

// string filters = 4;
inline void VectorSearchRequest::clear_filters() {
  filters_.ClearToEmpty();
}
inline const std::string& VectorSearchRequest::filters() const {
  // @@protoc_insertion_point(field_get:nnext.VectorSearchRequest.filters)
  return _internal_filters();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorSearchRequest::set_filters(ArgT0&& arg0, ArgT... args) {
 
 filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.VectorSearchRequest.filters)
}
inline std::string* VectorSearchRequest::mutable_filters() {
  std::string* _s = _internal_mutable_filters();
  // @@protoc_insertion_point(field_mutable:nnext.VectorSearchRequest.filters)
  return _s;
}
inline const std::string& VectorSearchRequest::_internal_filters() const {
  return filters_.Get();
}
inline void VectorSearchRequest::_internal_set_filters(const std::string& value) {
  
  filters_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VectorSearchRequest::_internal_mutable_filters() {
  
  return filters_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VectorSearchRequest::release_filters() {
  // @@protoc_insertion_point(field_release:nnext.VectorSearchRequest.filters)
  return filters_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VectorSearchRequest::set_allocated_filters(std::string* filters) {
  if (filters != nullptr) {
    
  } else {
    
  }
  filters_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filters,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filters_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filters_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.VectorSearchRequest.filters)
}

// bool omit_vector = 5;
inline void VectorSearchRequest::clear_omit_vector() {
  omit_vector_ = false;
}
inline bool VectorSearchRequest::_internal_omit_vector() const {
  return omit_vector_;
}
inline bool VectorSearchRequest::omit_vector() const {
  // @@protoc_insertion_point(field_get:nnext.VectorSearchRequest.omit_vector)
  return _internal_omit_vector();
}
inline void VectorSearchRequest::_internal_set_omit_vector(bool value) {
  
  omit_vector_ = value;
}
inline void VectorSearchRequest::set_omit_vector(bool value) {
  _internal_set_omit_vector(value);
  // @@protoc_insertion_point(field_set:nnext.VectorSearchRequest.omit_vector)
}

// bool omit_metadata = 6;
inline void VectorSearchRequest::clear_omit_metadata() {
  omit_metadata_ = false;
}
inline bool VectorSearchRequest::_internal_omit_metadata() const {
  return omit_metadata_;
}
inline bool VectorSearchRequest::omit_metadata() const {
  // @@protoc_insertion_point(field_get:nnext.VectorSearchRequest.omit_metadata)
  return _internal_omit_metadata();
}
inline void VectorSearchRequest::_internal_set_omit_metadata(bool value) {
  
  omit_metadata_ = value;
}
inline void VectorSearchRequest::set_omit_metadata(bool value) {
  _internal_set_omit_metadata(value);
  // @@protoc_insertion_point(field_set:nnext.VectorSearchRequest.omit_metadata)
}

// -------------------------------------------------------------------

// VectorSearchResponse

// string page = 1;
inline void VectorSearchResponse::clear_page() {
  page_.ClearToEmpty();
}
inline const std::string& VectorSearchResponse::page() const {
  // @@protoc_insertion_point(field_get:nnext.VectorSearchResponse.page)
  return _internal_page();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorSearchResponse::set_page(ArgT0&& arg0, ArgT... args) {
 
 page_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.VectorSearchResponse.page)
}
inline std::string* VectorSearchResponse::mutable_page() {
  std::string* _s = _internal_mutable_page();
  // @@protoc_insertion_point(field_mutable:nnext.VectorSearchResponse.page)
  return _s;
}
inline const std::string& VectorSearchResponse::_internal_page() const {
  return page_.Get();
}
inline void VectorSearchResponse::_internal_set_page(const std::string& value) {
  
  page_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VectorSearchResponse::_internal_mutable_page() {
  
  return page_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VectorSearchResponse::release_page() {
  // @@protoc_insertion_point(field_release:nnext.VectorSearchResponse.page)
  return page_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VectorSearchResponse::set_allocated_page(std::string* page) {
  if (page != nullptr) {
    
  } else {
    
  }
  page_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    page_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.VectorSearchResponse.page)
}

// uint64 ntotal = 2;
inline void VectorSearchResponse::clear_ntotal() {
  ntotal_ = uint64_t{0u};
}
inline uint64_t VectorSearchResponse::_internal_ntotal() const {
  return ntotal_;
}
inline uint64_t VectorSearchResponse::ntotal() const {
  // @@protoc_insertion_point(field_get:nnext.VectorSearchResponse.ntotal)
  return _internal_ntotal();
}
inline void VectorSearchResponse::_internal_set_ntotal(uint64_t value) {
  
  ntotal_ = value;
}
inline void VectorSearchResponse::set_ntotal(uint64_t value) {
  _internal_set_ntotal(value);
  // @@protoc_insertion_point(field_set:nnext.VectorSearchResponse.ntotal)
}

// repeated .nnext.Datum rptd__datum = 3;
inline int VectorSearchResponse::_internal_rptd__datum_size() const {
  return rptd__datum_.size();
}
inline int VectorSearchResponse::rptd__datum_size() const {
  return _internal_rptd__datum_size();
}
inline void VectorSearchResponse::clear_rptd__datum() {
  rptd__datum_.Clear();
}
inline ::nnext::Datum* VectorSearchResponse::mutable_rptd__datum(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorSearchResponse.rptd__datum)
  return rptd__datum_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
VectorSearchResponse::mutable_rptd__datum() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorSearchResponse.rptd__datum)
  return &rptd__datum_;
}
inline const ::nnext::Datum& VectorSearchResponse::_internal_rptd__datum(int index) const {
  return rptd__datum_.Get(index);
}
inline const ::nnext::Datum& VectorSearchResponse::rptd__datum(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorSearchResponse.rptd__datum)
  return _internal_rptd__datum(index);
}
inline ::nnext::Datum* VectorSearchResponse::_internal_add_rptd__datum() {
  return rptd__datum_.Add();
}
inline ::nnext::Datum* VectorSearchResponse::add_rptd__datum() {
  ::nnext::Datum* _add = _internal_add_rptd__datum();
  // @@protoc_insertion_point(field_add:nnext.VectorSearchResponse.rptd__datum)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
VectorSearchResponse::rptd__datum() const {
  // @@protoc_insertion_point(field_list:nnext.VectorSearchResponse.rptd__datum)
  return rptd__datum_;
}

// -------------------------------------------------------------------

// VectorGetRequest

// repeated .nnext.Datum data = 1;
inline int VectorGetRequest::_internal_data_size() const {
  return data_.size();
}
inline int VectorGetRequest::data_size() const {
  return _internal_data_size();
}
inline void VectorGetRequest::clear_data() {
  data_.Clear();
}
inline ::nnext::Datum* VectorGetRequest::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorGetRequest.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
VectorGetRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorGetRequest.data)
  return &data_;
}
inline const ::nnext::Datum& VectorGetRequest::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::nnext::Datum& VectorGetRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorGetRequest.data)
  return _internal_data(index);
}
inline ::nnext::Datum* VectorGetRequest::_internal_add_data() {
  return data_.Add();
}
inline ::nnext::Datum* VectorGetRequest::add_data() {
  ::nnext::Datum* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:nnext.VectorGetRequest.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
VectorGetRequest::data() const {
  // @@protoc_insertion_point(field_list:nnext.VectorGetRequest.data)
  return data_;
}

// string index_name = 2;
inline void VectorGetRequest::clear_index_name() {
  index_name_.ClearToEmpty();
}
inline const std::string& VectorGetRequest::index_name() const {
  // @@protoc_insertion_point(field_get:nnext.VectorGetRequest.index_name)
  return _internal_index_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VectorGetRequest::set_index_name(ArgT0&& arg0, ArgT... args) {
 
 index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:nnext.VectorGetRequest.index_name)
}
inline std::string* VectorGetRequest::mutable_index_name() {
  std::string* _s = _internal_mutable_index_name();
  // @@protoc_insertion_point(field_mutable:nnext.VectorGetRequest.index_name)
  return _s;
}
inline const std::string& VectorGetRequest::_internal_index_name() const {
  return index_name_.Get();
}
inline void VectorGetRequest::_internal_set_index_name(const std::string& value) {
  
  index_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VectorGetRequest::_internal_mutable_index_name() {
  
  return index_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VectorGetRequest::release_index_name() {
  // @@protoc_insertion_point(field_release:nnext.VectorGetRequest.index_name)
  return index_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VectorGetRequest::set_allocated_index_name(std::string* index_name) {
  if (index_name != nullptr) {
    
  } else {
    
  }
  index_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (index_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    index_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:nnext.VectorGetRequest.index_name)
}

// -------------------------------------------------------------------

// VectorGetResponse

// repeated .nnext.Datum data = 2;
inline int VectorGetResponse::_internal_data_size() const {
  return data_.size();
}
inline int VectorGetResponse::data_size() const {
  return _internal_data_size();
}
inline void VectorGetResponse::clear_data() {
  data_.Clear();
}
inline ::nnext::Datum* VectorGetResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorGetResponse.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
VectorGetResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorGetResponse.data)
  return &data_;
}
inline const ::nnext::Datum& VectorGetResponse::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::nnext::Datum& VectorGetResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorGetResponse.data)
  return _internal_data(index);
}
inline ::nnext::Datum* VectorGetResponse::_internal_add_data() {
  return data_.Add();
}
inline ::nnext::Datum* VectorGetResponse::add_data() {
  ::nnext::Datum* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:nnext.VectorGetResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
VectorGetResponse::data() const {
  // @@protoc_insertion_point(field_list:nnext.VectorGetResponse.data)
  return data_;
}

// -------------------------------------------------------------------

// VectorDeleteRequest

// repeated .nnext.Datum data = 1;
inline int VectorDeleteRequest::_internal_data_size() const {
  return data_.size();
}
inline int VectorDeleteRequest::data_size() const {
  return _internal_data_size();
}
inline void VectorDeleteRequest::clear_data() {
  data_.Clear();
}
inline ::nnext::Datum* VectorDeleteRequest::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorDeleteRequest.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
VectorDeleteRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorDeleteRequest.data)
  return &data_;
}
inline const ::nnext::Datum& VectorDeleteRequest::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::nnext::Datum& VectorDeleteRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorDeleteRequest.data)
  return _internal_data(index);
}
inline ::nnext::Datum* VectorDeleteRequest::_internal_add_data() {
  return data_.Add();
}
inline ::nnext::Datum* VectorDeleteRequest::add_data() {
  ::nnext::Datum* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:nnext.VectorDeleteRequest.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
VectorDeleteRequest::data() const {
  // @@protoc_insertion_point(field_list:nnext.VectorDeleteRequest.data)
  return data_;
}

// -------------------------------------------------------------------

// VectorDeleteResponse

// repeated .nnext.Datum data = 2;
inline int VectorDeleteResponse::_internal_data_size() const {
  return data_.size();
}
inline int VectorDeleteResponse::data_size() const {
  return _internal_data_size();
}
inline void VectorDeleteResponse::clear_data() {
  data_.Clear();
}
inline ::nnext::Datum* VectorDeleteResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorDeleteResponse.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
VectorDeleteResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorDeleteResponse.data)
  return &data_;
}
inline const ::nnext::Datum& VectorDeleteResponse::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::nnext::Datum& VectorDeleteResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorDeleteResponse.data)
  return _internal_data(index);
}
inline ::nnext::Datum* VectorDeleteResponse::_internal_add_data() {
  return data_.Add();
}
inline ::nnext::Datum* VectorDeleteResponse::add_data() {
  ::nnext::Datum* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:nnext.VectorDeleteResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
VectorDeleteResponse::data() const {
  // @@protoc_insertion_point(field_list:nnext.VectorDeleteResponse.data)
  return data_;
}

// -------------------------------------------------------------------

// VectorClearRequest

// repeated .nnext.Datum data = 1;
inline int VectorClearRequest::_internal_data_size() const {
  return data_.size();
}
inline int VectorClearRequest::data_size() const {
  return _internal_data_size();
}
inline void VectorClearRequest::clear_data() {
  data_.Clear();
}
inline ::nnext::Datum* VectorClearRequest::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorClearRequest.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
VectorClearRequest::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorClearRequest.data)
  return &data_;
}
inline const ::nnext::Datum& VectorClearRequest::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::nnext::Datum& VectorClearRequest::data(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorClearRequest.data)
  return _internal_data(index);
}
inline ::nnext::Datum* VectorClearRequest::_internal_add_data() {
  return data_.Add();
}
inline ::nnext::Datum* VectorClearRequest::add_data() {
  ::nnext::Datum* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:nnext.VectorClearRequest.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
VectorClearRequest::data() const {
  // @@protoc_insertion_point(field_list:nnext.VectorClearRequest.data)
  return data_;
}

// -------------------------------------------------------------------

// VectorClearResponse

// repeated .nnext.Datum data = 2;
inline int VectorClearResponse::_internal_data_size() const {
  return data_.size();
}
inline int VectorClearResponse::data_size() const {
  return _internal_data_size();
}
inline void VectorClearResponse::clear_data() {
  data_.Clear();
}
inline ::nnext::Datum* VectorClearResponse::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:nnext.VectorClearResponse.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >*
VectorClearResponse::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:nnext.VectorClearResponse.data)
  return &data_;
}
inline const ::nnext::Datum& VectorClearResponse::_internal_data(int index) const {
  return data_.Get(index);
}
inline const ::nnext::Datum& VectorClearResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:nnext.VectorClearResponse.data)
  return _internal_data(index);
}
inline ::nnext::Datum* VectorClearResponse::_internal_add_data() {
  return data_.Add();
}
inline ::nnext::Datum* VectorClearResponse::add_data() {
  ::nnext::Datum* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:nnext.VectorClearResponse.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::nnext::Datum >&
VectorClearResponse::data() const {
  // @@protoc_insertion_point(field_list:nnext.VectorClearResponse.data)
  return data_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nnext

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::nnext::IndexType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nnext::IndexType>() {
  return ::nnext::IndexType_descriptor();
}
template <> struct is_proto_enum< ::nnext::MetricType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nnext::MetricType>() {
  return ::nnext::MetricType_descriptor();
}
template <> struct is_proto_enum< ::nnext::DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::nnext::DataType>() {
  return ::nnext::DataType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_main_2eproto
